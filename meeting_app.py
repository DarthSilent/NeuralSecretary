import os
import sys
import logging
from logging.handlers import RotatingFileHandler

# --- 1. –ù–ê–°–¢–†–û–ô–ö–ê –ü–£–¢–ï–ô –î–õ–Ø PORTABLE / PYINSTALLER ---
if getattr(sys, "frozen", False):
    internal_path = sys._MEIPASS
    # –ï—Å–ª–∏ —ç—Ç–æ EXE, —Ö—Ä–∞–Ω–∏–º –¥–∞–Ω–Ω—ã–µ –≤ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —á—Ç–æ–±—ã –Ω–µ —Ç—Ä–µ–±–æ–≤–∞—Ç—å –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∞
    external_path = os.path.join(os.path.expanduser("~"), "Documents", "MeetingApp")
    os.makedirs(external_path, exist_ok=True)
else:
    internal_path = os.getcwd()
    external_path = os.getcwd()

os.environ["PATH"] += os.pathsep + internal_path
os.chdir(external_path)

# Add nvidia CUDA 12 DLL directories to PATH for faster-whisper
try:
    import site
    site_packages = site.getsitepackages()
    for sp in site_packages:
        nvidia_cublas_bin = os.path.join(sp, "nvidia", "cublas", "bin")
        nvidia_cudnn_bin = os.path.join(sp, "nvidia", "cudnn", "bin")
        if os.path.exists(nvidia_cublas_bin):
            os.environ["PATH"] = nvidia_cublas_bin + os.pathsep + os.environ["PATH"]
        if os.path.exists(nvidia_cudnn_bin):
            os.environ["PATH"] = nvidia_cudnn_bin + os.pathsep + os.environ["PATH"]
except Exception:
    pass

import warnings
warnings.filterwarnings("ignore")

import queue
import json
import requests
import re
import zipfile
import shutil
import subprocess
import uuid
from io import BytesIO
from datetime import datetime, timedelta
import threading
import time
class OperationCancelled(Exception): pass

# Import file association manager
from file_association_manager import FileAssociationManager

# --- 2. –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ò–†–û–í–ê–ù–ò–Ø ---
LOG_FILE = "meeting_app.log"
logger = logging.getLogger("MeetingApp")
logger.setLevel(logging.DEBUG)

file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=3, encoding='utf-8')
file_handler.setLevel(logging.DEBUG)
file_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(file_formatter)
logger.addHandler(file_handler)

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(levelname)s: %(message)s')
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

logger.info("========== Meeting App Started ==========")

import tkinter as tk
from tkinter import filedialog, messagebox

import customtkinter as ctk
import sounddevice as sd
import soundfile as sf
import numpy as np

import torch
import torchaudio
from dataclasses import dataclass

# --- MONKEYPATCH: FIX PYANNOTE.AUDIO MISSING TORCHCODEC ---
# Pyannote 3.3+ requires torchcodec, which is hard to install on Windows.
# We inject a compatibility layer using torchaudio.
try:
    import pyannote.audio.core.io
    
    # Always apply patch if AudioDecoder is missing OR if we want to force our logging version
    # But to be safe, we check if it's missing or if it's our own class
    if not hasattr(pyannote.audio.core.io, "AudioDecoder") or getattr(pyannote.audio.core.io.AudioDecoder, "__module__", "") == __name__:
        logger.info("Applying AudioDecoder monkeypatch for pyannote.audio...")
        
        @dataclass
        class AudioStreamMetadata:
            sample_rate: int
            duration_seconds_from_header: float
            num_channels: int

        @dataclass
        class AudioSamples:
            data: torch.Tensor
            sample_rate: int

        class AudioDecoder:
            def __init__(self, path):
                logger.debug(f"AudioDecoder init for {path}")
                self.path = path
                try:
                    self.info = torchaudio.info(path)
                    logger.debug(f"torchaudio.info success: {self.info}")
                except Exception as e:
                    logger.error(f"Error getting info for {path}: {e}")
                    raise

            @property
            def metadata(self):
                return AudioStreamMetadata(
                    sample_rate=self.info.sample_rate,
                    duration_seconds_from_header=self.info.num_frames / self.info.sample_rate,
                    num_channels=self.info.num_channels
                )

            def get_all_samples(self):
                logger.debug(f"get_all_samples for {self.path}")
                try:
                    waveform, sr = torchaudio.load(self.path)
                    logger.debug(f"torchaudio.load success, shape={waveform.shape}, sr={sr}")
                    return AudioSamples(data=waveform, sample_rate=sr)
                except Exception as e:
                    logger.error(f"torchaudio.load failed: {e}")
                    raise

            def get_samples_played_in_range(self, start, end):
                # logger.info(f"get_samples_played_in_range {start}-{end}")
                info = self.info
                sr = info.sample_rate
                frame_offset = int(start * sr)
                num_frames = int((end - start) * sr)
                
                waveform, sr = torchaudio.load(
                    self.path,
                    frame_offset=frame_offset,
                    num_frames=num_frames
                )
                return AudioSamples(data=waveform, sample_rate=sr)

        # Inject into pyannote.audio.core.io
        pyannote.audio.core.io.AudioDecoder = AudioDecoder
        pyannote.audio.core.io.AudioStreamMetadata = AudioStreamMetadata
        pyannote.audio.core.io.AudioSamples = AudioSamples
        
        # Inject into pyannote.audio.pipelines.utils (to fix warning)
        try:
            import pyannote.audio.pipelines.utils
            pyannote.audio.pipelines.utils.AudioDecoder = AudioDecoder
            logger.info("Injected AudioDecoder into pyannote.audio.pipelines.utils")
        except Exception as e:
            logger.warning(f"Could not inject into pipelines.utils: {e}")

        logger.info("AudioDecoder monkeypatch applied successfully.")

except Exception as e:
    logger.error(f"Failed to apply AudioDecoder monkeypatch: {e}")

# —Ç—è–∂—ë–ª—ã–µ –≤–µ—â–∏ –Ω—É–∂–Ω—ã —Å—Ä–∞–∑—É
import torch
import torchaudio
from scipy.spatial.distance import cdist
from pyannote.core import Annotation

# Pydub ‚Äì –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å
try:
    from pydub import AudioSegment
except ImportError:
    messagebox.showerror(
        "–û—à–∏–±–∫–∞",
        "–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ pydub.\n"
        "–£—Å—Ç–∞–Ω–æ–≤–∏ –µ—ë –∫–æ–º–∞–Ω–¥–æ–π:\n\n    pip install pydub\n"
    )
    sys.exit(1)

# Google Drive ‚Äì –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
try:
    from google.oauth2.credentials import Credentials
    from googleapiclient.discovery import build
    from googleapiclient.http import MediaFileUpload
    from google_auth_oauthlib.flow import InstalledAppFlow
    from google.auth.transport.requests import Request
    GDRIVE_AVAILABLE = True
except ImportError:
    GDRIVE_AVAILABLE = False

# DOCX ‚Äì —Ç–æ–∂–µ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
try:
    from docx import Document
    from docx.shared import Pt
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False


# --- –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ù–ê–°–¢–†–û–ô–ö–ò ---

APP_TITLE = "–ù–µ–π—Ä–æ –°—Ç–µ–Ω–æ–≥—Ä–∞—Ñ–∏—Å—Ç v0.5 Beta"

DB_FILE = "voice_db.pkl"
SETTINGS_FILE = "settings.json"
RECORDS_DIR = os.path.join(external_path, "Meeting_Records")
SAMPLES_DIR = os.path.join(external_path, "Voice_Samples")
TEMP_DIR = os.path.join(external_path, "temp_segments")

os.makedirs(RECORDS_DIR, exist_ok=True)
os.makedirs(SAMPLES_DIR, exist_ok=True)
GDRIVE_FOLDER = "NeuroStenographer_Records"

BUILTIN_PROMPTS = {
    "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π": """–¢–≤–æ—è —Ä–æ–ª—å: –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –±–∏–∑–Ω–µ—Å-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä —Ç–µ–∫—Å—Ç–æ–≤.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –†–∞–±–æ—Ç–∞–π —Ç–æ–ª—å–∫–æ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –∏–∑ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—ã. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Ñ–∞–∫—Ç—ã, —Ü–∏—Ñ—Ä—ã, –∏–º–µ–Ω–∞ –∏ —Ü–∏—Ç–∞—Ç—ã.
2. –ï—Å–ª–∏ –∫–∞–∫–∏—Ö-—Ç–æ –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç, —è–≤–Ω–æ –ø–æ–º–µ—á–∞–π —ç—Ç–æ –∫–∞–∫ "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö" –∏–ª–∏ –ø—Ä–æ–ø—É—Å–∫–∞–π –ø–æ–ª–µ, –∞ –Ω–µ —Ñ–∞–Ω—Ç–∞–∑–∏—Ä—É–π.
3. –ù–µ –æ–ø–∏—Å—ã–≤–∞–π —ç—Ç–∞–ø—ã –∞–Ω–∞–ª–∏–∑–∞. –í –æ—Ç–≤–µ—Ç–µ –ø–æ–∫–∞–∑—ã–≤–∞–π —Ç–æ–ª—å–∫–æ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª.
4. –ü–∏—à–∏ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ, –æ—Ç —Ç—Ä–µ—Ç—å–µ–≥–æ –ª–∏—Ü–∞, –±–µ–∑ –ª–∏—á–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –∏ –æ—Ü–µ–Ω–æ–∫.

–í–ê–ñ–ù–´–ô –≠–¢–ê–ü –ê–ù–ê–õ–ò–ó–ê (–≤—ã–ø–æ–ª–Ω–∏—Ç—å –≤ —É–º–µ):
1. –¢—ã –ø–æ–ª—É—á–∞–µ—à—å —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—É –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞. –í —Ç–µ–∫—Å—Ç–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –µ—Å—Ç—å –æ—à–∏–±–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è (–æ–º–æ–Ω–∏–º—ã, –æ–∫–æ–Ω—á–∞–Ω–∏—è, –ø—É–Ω–∫—Ç—É–∞—Ü–∏—è, –∏–º–µ–Ω–∞).
2. –¢–≤–æ—è –ø–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ ‚Äì –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–º—ã—Å–ª –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –±–µ—Å–µ–¥—ã –∏ –ª–æ–≥–∏–∫–µ –¥–∏–∞–ª–æ–≥–∞, –¥–∞–∂–µ –µ—Å–ª–∏ —Ñ—Ä–∞–∑—ã –æ–±—Ä—ã–≤–æ—á–Ω—ã–µ.
3. –ò–≥–Ω–æ—Ä–∏—Ä—É–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —à—É–º –∏ —Å–ª—É–∂–µ–±–Ω—ã–µ —Ä–µ–ø–ª–∏–∫–∏ ("—Ä–∞–∑-—Ä–∞–∑", "—Å–ª—ã—à–Ω–æ?", "—Å–µ–π—á–∞—Å –ø–µ—Ä–µ–∑–∞–π–¥—É" –∏ —Ç.–ø.).

–§–û–†–ú–ê–¢ –û–¢–ß–ï–¢–ê (Markdown):
# üìù –ü—Ä–æ—Ç–æ–∫–æ–ª –≤—Å—Ç—Ä–µ—á–∏
**–î–∞—Ç–∞:** {date}

## üéØ –ö—Ä–∞—Ç–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ (Executive Summary)
(–°–∂–∞—Ç—ã–π –ø–µ—Ä–µ—Å–∫–∞–∑ –±–µ—Å–µ–¥—ã –≤ 3‚Äì4 –∞–±–∑–∞—Ü–∞—Ö: —Ü–µ–ª–∏ –≤—Å—Ç—Ä–µ—á–∏, –∫–ª—é—á–µ–≤—ã–µ —Ç–µ–∑–∏—Å—ã, –±—ã–ª–∏ –ª–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã, –∫ –∫–∞–∫–æ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –ø—Ä–∏—à–ª–∏.)

## ‚úÖ –ü—Ä–∏–Ω—è—Ç—ã–µ —Ä–µ—à–µ–Ω–∏—è
* (–¢–æ–ª—å–∫–æ —Ç–≤–µ—Ä–¥—ã–µ –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç–∏, —Å—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–∞–∫ —Ä–µ—à–µ–Ω–∏—è, –±–µ–∑ –ø–ª–∞–Ω–æ–≤ –∏ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–π.)

## üõ† –ü–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π (Action Items)
| –ó–∞–¥–∞—á–∞ | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ä–æ–∫–∏ |
|--------|---------------|-------|
| ...    | ...           | ...   |
(–ó–∞–ø–æ–ª–Ω–∏ –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –ï—Å–ª–∏ –∑–∞–¥–∞—á –Ω–µ—Ç ‚Äì —è–≤–Ω–æ –Ω–∞–ø–∏—à–∏ "–Ω–µ—Ç –∑–∞–¥–∞—á".)

## ‚ùì –û—Ç–∫—Ä—ã—Ç—ã–µ –≤–æ–ø—Ä–æ—Å—ã
* (–û —á–µ–º –Ω–µ —Å–º–æ–≥–ª–∏ –¥–æ–≥–æ–≤–æ—Ä–∏—Ç—å—Å—è, –∫–∞–∫–∏–µ —Ç–µ–º—ã –æ—Ç–ª–æ–∂–∏–ª–∏, –∫–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –µ—â–µ –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å.)

–°—Ç–∏–ª—å: –¥–µ–ª–æ–≤–æ–π, —Å—É—Ö–æ–π, –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π, –±–µ–∑ "–≤–æ–¥—ã" –∏ –º–∞—Ä–∫–µ—Ç–∏–Ω–≥–æ–≤—ã—Ö –æ–±–æ—Ä–æ—Ç–æ–≤.""",
    "IT": """–¢–≤–æ—è —Ä–æ–ª—å: —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä (Technical PM).
–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ ‚Äì —Å—ã—Ä–∞—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è —Å–æ–∑–≤–æ–Ω–∞ –∏–Ω–∂–µ–Ω–µ—Ä–æ–≤.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –ü–∏—à–∏ –æ—Ç—á–µ—Ç –¥–ª—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –∞—É–¥–∏—Ç–æ—Ä–∏–∏. –ù–µ –æ–±—ä—è—Å–Ω—è–π –±–∞–∑–æ–≤—ã–µ IT-—Ç–µ—Ä–º–∏–Ω—ã.
2. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Ä–µ—à–µ–Ω–∏—è, —Å—Ä–æ–∫–∏ –∏ –æ—Ü–µ–Ω–∫–∏, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ.
3. –ï—Å–ª–∏ –≤ —Ä–µ—á–∏ –Ω–µ –Ω–∞–∑–≤–∞–Ω—ã –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏–ª–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç ‚Äì –ø–æ–º–µ—Ç—å "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö", –Ω–µ –≤—ã–¥—É–º—ã–≤–∞–π.
4. –ß–µ—Ç–∫–æ –æ—Ç–¥–µ–ª—è–π —Ñ–∞–∫—Ç—ã (—á—Ç–æ —É–∂–µ —Å–¥–µ–ª–∞–ª–∏) –æ—Ç –ø–ª–∞–Ω–æ–≤ (—á—Ç–æ —Ç–æ–ª—å–∫–æ –ø–ª–∞–Ω–∏—Ä—É—é—Ç).

–ò–ù–°–¢–†–£–ö–¶–ò–Ø:
1. –ê–í–¢–û–ö–û–†–†–ï–ö–¶–ò–Ø: –Ω–æ—Ä–º–∞–ª–∏–∑—É–π IT-—Ç–µ—Ä–º–∏–Ω—ã (backend, —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥, –¥–µ–ø–ª–æ–π, merge, feature, Python –∏ —Ç.–ø.), –≤—ã–ø—Ä–∞–≤—å –≥—Ä–∞–º–º–∞—Ç–∏–∫—É –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–º—ã—Å–ª–∞.
2. –§–ò–õ–¨–¢–†: —É–¥–∞–ª–∏ —Å–º–æ–ª-—Ç–æ–∫, —à—É—Ç–∫–∏ –∏ –Ω–µ—Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–µ –≤—Å—Ç–∞–≤–∫–∏. –û—Å—Ç–∞–≤—å —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ –≤–ª–∏—è–µ—Ç –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç, —Å—Ä–æ–∫–∏, –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É, –∫–∞—á–µ—Å—Ç–≤–æ.

–§–û–†–ú–ê–¢ –û–¢–ß–ï–¢–ê (Markdown):
# üèóÔ∏è Tech Sync / Meeting Report ({date})

## üìå Summary
(–ö—Ä–∞—Ç–∫–æ –æ–ø–∏—à–∏ —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å –ø—Ä–æ–µ–∫—Ç–∞, –¥–æ—Å—Ç–∏–≥–Ω—É—Ç—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –∑–∞ –ø–µ—Ä–∏–æ–¥ –∏ –∫–ª—é—á–µ–≤—ã–µ –±–ª–æ–∫–µ—Ä—ã, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å.)

## üöÄ Decisions (–†–µ—à–µ–Ω–∏—è)
* (–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è, –ø–æ –∫–æ—Ç–æ—Ä—ã–º —É—á–∞—Å—Ç–Ω–∏–∫–∏ —è–≤–Ω–æ –¥–æ–≥–æ–≤–æ—Ä–∏–ª–∏—Å—å.)

## üîß Action Items
| Task | Assignee | Priority |
|------|----------|----------|
| ...  | ...      | ...      |

## üêû Bugs & Risks
* (–í—ã—è–≤–ª–µ–Ω–Ω—ã–µ –±–∞–≥–∏, —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–ª–≥ –∏ —Ä–∏—Å–∫–∏ —Å –∫—Ä–∞—Ç–∫–∏–º –ø–æ—è—Å–Ω–µ–Ω–∏–µ–º: –≤ —á–µ–º —Å—É—Ç—å –∏ –∫–∞–∫ —ç—Ç–æ –≤–ª–∏—è–µ—Ç –Ω–∞ –ø—Ä–æ–µ–∫—Ç.)

–°—Ç–∏–ª—å: —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π, –ª–∞–∫–æ–Ω–∏—á–Ω—ã–π, —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π.""",
    "–ü—Ä–æ–¥–∞–∂–∏ / CRM": """–¢–≤–æ—è —Ä–æ–ª—å: –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –æ—Ç–¥–µ–ª–∞ –ø—Ä–æ–¥–∞–∂.
–ó–∞–¥–∞—á–∞: –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—ã –≤—Å—Ç—Ä–µ—á–∏ –∑–∞–ø–æ–ª–Ω–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∫–∞—Ä—Ç–æ—á–∫—É –¥–ª—è CRM.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –§–∏–∫—Å–∏—Ä—É–π —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–æ–∑–≤—É—á–∞–ª–æ. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –±—é–¥–∂–µ—Ç, —Å—Ä–æ–∫–∏, –ª–∏—Ü, —Ä–µ—à–µ–Ω–∏—è.
2. –°–æ—Ö—Ä–∞–Ω—è–π —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏ –∫–ª–∏–µ–Ω—Ç–∞ (–æ—Å–æ–±–µ–Ω–Ω–æ "–±–æ–ª–∏" –∏ –≤–æ–∑—Ä–∞–∂–µ–Ω–∏—è) –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±–ª–∏–∑–∫–æ –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É.
3. –ï—Å–ª–∏ –∫–∞–∫–æ–π-—Ç–æ –±–ª–æ–∫ –Ω–µ –æ–±—Å—É–∂–¥–∞–ª—Å—è ‚Äì —Ç–∞–∫ –∏ –ø–∏—à–∏: "–Ω–µ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å" –∏–ª–∏ "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö".
4. –ù–µ –¥–æ–±–∞–≤–ª—è–π —Å–≤–æ–∏ —Å–æ–≤–µ—Ç—ã –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏. –¢–æ–ª—å–∫–æ —Ñ–∞–∫—Ç—ã –≤—Å—Ç—Ä–µ—á–∏ –∏ –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç–∏.

–§–û–†–ú–ê–¢:
# üíº –í—Å—Ç—Ä–µ—á–∞ —Å –∫–ª–∏–µ–Ω—Ç–æ–º {date}

## üë§ –ö–ª–∏–µ–Ω—Ç
(–ö—Ç–æ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–æ–≤–∞–ª —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã –∫–ª–∏–µ–Ω—Ç–∞: –§–ò–û, —Ä–æ–ª–∏, –∫–æ–º–ø–∞–Ω–∏—è. –ï—Å–ª–∏ –∏–º—è –Ω–µ—Ä–∞–∑–±–æ—Ä—á–∏–≤–æ ‚Äì –ø–æ–º–µ—Ç—å –∫–∞–∫ "–∏–º—è –Ω–µ—Ä–∞–∑–±–æ—Ä—á–∏–≤–æ".)

## üò´ "–ë–æ–ª–∏" –∏ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç–∏
* (–ö–∞–∫–∏–µ –∑–∞–¥–∞—á–∏ –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã –∫–ª–∏–µ–Ω—Ç —Ö–æ—á–µ—Ç —Ä–µ—à–∏—Ç—å. –ö–∞–∂–¥—ã–π –ø—É–Ω–∫—Ç ‚Äì –æ—Ç–¥–µ–ª—å–Ω–∞—è –±–æ–ª—å –∏–ª–∏ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å.)

## üí∞ –ë—é–¥–∂–µ—Ç –∏ —Å—Ä–æ–∫–∏
* (–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Å—É–º–º—ã, –¥–∏–∞–ø–∞–∑–æ–Ω—ã, –≤–∞–ª—é—Ç—ã, –ø–ª–∞–Ω–æ–≤—ã–µ —Å—Ä–æ–∫–∏. –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å ‚Äì —è–≤–Ω–æ –æ—Ç–º–µ—Ç—å.)

## üõ°Ô∏è –í–æ–∑—Ä–∞–∂–µ–Ω–∏—è
* (–ß—Ç–æ —Å–º—É—â–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞: "–¥–æ—Ä–æ–≥–æ", "–Ω–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏", "—Å–ª–æ–∂–Ω–æ –≤–Ω–µ–¥—Ä—è—Ç—å" –∏ —Ç.–ø. –ü–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ ‚Äì –¥–æ—Å–ª–æ–≤–Ω–æ.)

## ‚úÖ Next Steps
| –ú—ã –¥–µ–ª–∞–µ–º | –ö–ª–∏–µ–Ω—Ç –¥–µ–ª–∞–µ—Ç | –î–∞—Ç–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞ |
|-----------|---------------|---------------|
| ...       | ...           | ...           |

(–û—Ç—Ä–∞–∂–∞–π —Ç–æ–ª—å–∫–æ —Ç–µ —à–∞–≥–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–æ–≥–æ–≤–æ—Ä–∏–ª–∏. –ï—Å–ª–∏ –¥–∞—Ç–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∫–æ–Ω—Ç–∞–∫—Ç–∞ –Ω–µ –Ω–∞–∑–≤–∞–Ω–∞ ‚Äì –Ω–∞–ø–∏—à–∏ "–¥–∞—Ç–∞ –Ω–µ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∞".)

–°—Ç–∏–ª—å: —è—Å–Ω—ã–π, —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–π, –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –ø–æ—Å–ª–µ–¥—É—é—â—É—é —Ä–∞–±–æ—Ç—É –≤ CRM.""",
    "–ë—Ä–µ–π–Ω—à—Ç–æ—Ä–º": """–¢–≤–æ—è —Ä–æ–ª—å: –∫—Ä–µ–∞—Ç–∏–≤–Ω—ã–π —Å–∫—Ä–∞–π–±–µ—Ä.
–ó–∞–¥–∞—á–∞: –≤—ã–ª–æ–≤–∏—Ç—å –∏–¥–µ–∏ –∏–∑ —Ö–∞–æ—Ç–∏—á–Ω–æ–π –¥–∏—Å–∫—É—Å—Å–∏–∏. –£–±–µ—Ä–∏ –º—É—Å–æ—Ä, –Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏ —ç–Ω–µ—Ä–≥–∏—é –∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –º—ã—Å–ª–µ–π.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –∏–¥–µ–∏ –æ—Ç —Å–µ–±—è. –§–∏–∫—Å–∏—Ä—É–π —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ –∑–≤—É—á–∞–ª–æ.
2. –ù–µ —Å–∫–ª–µ–∏–≤–∞–π —Ä–∞–∑–Ω—ã–µ –∏–¥–µ–∏ –≤ –æ–¥–Ω—É, –µ—Å–ª–∏ –æ–Ω–∏ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –ø–æ —Å—É—Ç–∏.
3. –°–æ—Ö—Ä–∞–Ω—è–π –∞–≤—Ç–æ—Ä—Å—Ç–≤–æ –∏–¥–µ–∏, –µ—Å–ª–∏ –µ–≥–æ –º–æ–∂–Ω–æ –ø–æ–Ω—è—Ç—å –∏–∑ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—ã.
4. –û—Å—Ç–∞–≤–ª—è–π –∏ —Å–º–µ–ª—ã–µ/—Å—ã—Ä—ã–µ –∏–¥–µ–∏, –µ—Å–ª–∏ –æ–Ω–∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–æ –Ω–∏–º —Å—Ä–∞–∑—É –ø—Ä–æ–∑–≤—É—á–∞–ª–∞ –∫—Ä–∏—Ç–∏–∫–∞.

–§–û–†–ú–ê–¢:
# üß† –ë—Ä–µ–π–Ω—à—Ç–æ—Ä–º {date}

## üå°Ô∏è –í–∞–π–±
(–ö—Ä–∞—Ç–∫–æ –æ–ø–∏—à–∏ –∞—Ç–º–æ—Å—Ñ–µ—Ä—É –≤—Å—Ç—Ä–µ—á–∏: –æ —á–µ–º —Å–ø–æ—Ä–∏–ª–∏, –∫–∞–∫–∏–µ –±—ã–ª–∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –ª–∏–Ω–∏–∏ —Ä–∞–∑–Ω–æ–≥–ª–∞—Å–∏–π –∏ —Å–æ–≥–ª–∞—Å–∏—è.)

## üíé –ó–æ–ª–æ—Ç—ã–µ –∏–¥–µ–∏
* (–°–ø–∏—Å–æ–∫ —Å–∏–ª—å–Ω—ã—Ö, –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã—Ö –∏–¥–µ–π. –ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Äì –æ–¥–Ω–∞ –∏–¥–µ—è, —Å—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ —Å—É—Ç–∏.)

## üó£Ô∏è –•–æ–¥ –º—ã—Å–ª–µ–π
(–ö–∞–∫ —Ä–∞–∑–≤–∏–≤–∞–ª–∞—Å—å –¥–∏—Å–∫—É—Å—Å–∏—è: –æ—Ç –∫–∞–∫–∏—Ö –∏—Å—Ö–æ–¥–Ω—ã—Ö —Ç–µ–∑–∏—Å–æ–≤ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –ø—Ä–∏—à–ª–∏ –∫ —Ç–µ–∫—É—â–∏–º –∏–¥–µ—è–º –∏ –≤—ã–≤–æ–¥–∞–º.)

## üí¨ –¶–∏—Ç–∞—Ç—ã
(–î–æ 3‚Äì5 —è—Ä–∫–∏—Ö —Ñ—Ä–∞–∑ –¥–æ—Å–ª–æ–≤–Ω–æ. –ù–µ –ø—Ä–∞–≤—å —Å—Ç–∏–ª—å –∏ —ç–º–æ—Ü–∏–∏, —Ç–æ–ª—å–∫–æ —è–≤–Ω—ã–µ –æ—à–∏–±–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è.)

## üöÄ –ö –ø—Ä–æ–≤–µ—Ä–∫–µ
| –ò–¥–µ—è | –ö—Ç–æ –±–µ—Ä–µ—Ç |
|------|-----------|
| ...  | ...       |

–°—Ç–∏–ª—å: –∂–∏–≤–æ–π, –Ω–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π. –≠–Ω–µ—Ä–≥–∏—è –≤—Å—Ç—Ä–µ—á–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞, —Ö–∞–æ—Å ‚Äì —É–±—Ä–∞–Ω.""",
    "HR / –°–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞": """–¢–≤–æ—è —Ä–æ–ª—å: HR-—Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç –∏–ª–∏ —Ä–µ–∫—Ä—É—Ç–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –æ—Ñ–æ—Ä–º–ª—è–µ—Ç –∏—Ç–æ–≥–∏ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è –ø–æ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º–µ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –æ–ø—ã—Ç, –Ω–∞–≤—ã–∫–∏, —Å—É–º–º—ã –∏ —Ñ–æ—Ä–º–∞—Ç—ã —Ä–∞–±–æ—Ç—ã, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º–µ.
2. –ï—Å–ª–∏ —á–∞—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ä–∞–∑–±–æ—Ä—á–∏–≤–∞, –ø–æ–º–µ—á–∞–π —ç—Ç–æ –∫–∞–∫ "–Ω–µ—Ä–∞–∑–±–æ—Ä—á–∏–≤–æ" –∏–ª–∏ "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö".
3. –†–∞–∑–¥–µ–ª—è–π —Ñ–∞–∫—Ç—ã –∏–∑ —Ä–µ—á–∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –∏–Ω—Ç–µ—Ä–≤—å—é–µ—Ä–∞. –ù–µ –¥–æ–±–∞–≤–ª—è–π —Å–≤–æ–∏ –æ—Ü–µ–Ω–∫–∏.
4. –ù–µ —Å–º—è–≥—á–∞–π –∏ –Ω–µ —É—Å–∏–ª–∏–≤–∞–π —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞, –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –∏ —Ä–∏—Å–∫–∞–º.

–§–û–†–ú–ê–¢:
# –û—Ç—á–µ—Ç –ø–æ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—é {date}

## –ö–∞–Ω–¥–∏–¥–∞—Ç
(–§–ò–û, –∂–µ–ª–∞–µ–º–∞—è –ø–æ–∑–∏—Ü–∏—è, —Ç–µ–∫—É—â–∞—è —Ä–æ–ª—å –∏ –∫–æ–º–ø–∞–Ω–∏—è, –µ—Å–ª–∏ —ç—Ç–æ —è–≤–Ω–æ –ø—Ä–æ–∑–≤—É—á–∞–ª–æ.)

## –û–ø—ã—Ç –∏ –∫–æ–º–ø–µ—Ç–µ–Ω—Ü–∏–∏
* (–ö—Ä–∞—Ç–∫–∞—è –∏—Å—Ç–æ—Ä–∏—è –æ–ø—ã—Ç–∞, –∫–ª—é—á–µ–≤—ã–µ –¥–æ–º–µ–Ω—ã –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏. –û—Ç–¥–µ–ª—å–Ω—ã–º–∏ –ø—É–Ω–∫—Ç–∞–º–∏.)

## –ú–æ—Ç–∏–≤–∞—Ü–∏—è –∏ –æ–∂–∏–¥–∞–Ω–∏—è
* (–ü—Ä–∏—á–∏–Ω—ã —Å–º–µ–Ω—ã —Ä–∞–±–æ—Ç—ã, –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ —Ä–æ–ª–∏, –∑–∞–¥–∞—á–∞–º, –∫–æ–º–∞–Ω–¥–µ, —Ñ–æ—Ä–º–∞—Ç—É —Ä–∞–±–æ—Ç—ã, –∑–∞—Ä–∞–±–æ—Ç–Ω–æ–π –ø–ª–∞—Ç–µ.)

## –û—Ü–µ–Ω–∫–∞ –ø–æ –∫–ª—é—á–µ–≤—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
| –ö—Ä–∏—Ç–µ—Ä–∏–π                | –û—Ü–µ–Ω–∫–∞      | –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π |
|-------------------------|-------------|-------------|
| –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –Ω–∞–≤—ã–∫–∏ | ...         | ...         |
| Soft skills             | ...         | ...         |
| –ö—É–ª—å—Ç—É—Ä–∞ –∏ —Ü–µ–Ω–Ω–æ—Å—Ç–∏     | ...         | ...         |
| –°–∞–º–æ–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è         | ...         | ...         |

## –†–∏—Å–∫–∏ –∏ –≤–æ–ø—Ä–æ—Å—ã
* (–ß—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç —Å–æ–º–Ω–µ–Ω–∏—è –ø–æ –∫–∞–Ω–¥–∏–¥–∞—Ç—É, –∫–∞–∫–∏–µ –º–æ–º–µ–Ω—Ç—ã —Ç—Ä–µ–±—É—é—Ç –¥–æ–ø—Ä–æ–≤–µ—Ä–∫–∏.)

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –¥–∞–ª—å–Ω–µ–π—à–∏–º —à–∞–≥–∞–º
* (–ù–∞–ø—Ä–∏–º–µ—Ä: "–ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å –Ω–∞ —Ç–µ—Ö–∏–Ω—Ç–µ—Ä–≤—å—é", "–∑–∞–ø—Ä–æ—Å–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ", "–æ—Ç–∫–∞–∑–∞—Ç—å". –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ —è–≤–Ω–æ –ø—Ä–æ–≥–æ–≤–æ—Ä–µ–Ω–æ.)""",
    "–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å / –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å": """–¢–≤–æ—è —Ä–æ–ª—å: —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –∫–æ–º–∞–Ω–¥—ã, –∫–æ—Ç–æ—Ä—ã–π –æ—Ñ–æ—Ä–º–ª—è–µ—Ç –∏—Ç–æ–≥–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å –ø–æ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º–µ –ø–ª–∞–Ω–µ—Ä–∫–∏.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Å—è –Ω–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ –ø–æ –∑–∞–¥–∞—á–∞–º, –ø—Ä–æ–±–ª–µ–º–∞—Ö, —Ä–µ—à–µ–Ω–∏—è—Ö –∏ –ø–ª–∞–Ω–∞—Ö.
2. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Å—Ç–∞—Ç—É—Å—ã –∏ —Å—Ä–æ–∫–∏, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –Ω–∞–∑–≤–∞–Ω—ã. –¢–æ–≥–¥–∞ –ø–∏—à–∏ "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö".
3. –ù–µ –æ–ø–∏—Å—ã–≤–∞–π –ø—Ä–æ—Ü–µ—Å—Å –æ–±—Å—É–∂–¥–µ–Ω–∏—è, —Ñ–∏–∫—Å–∏—Ä—É–π —Ç–æ–ª—å–∫–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

–§–û–†–ú–ê–¢:
# –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å –∫–æ–º–∞–Ω–¥—ã {date}

## –û–±—â–∞—è –∫–∞—Ä—Ç–∏–Ω–∞
(–ö—Ä–∞—Ç–∫–æ: —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å –∫–æ–º–∞–Ω–¥–æ–π –∏–ª–∏ –ø—Ä–æ–µ–∫—Ç–æ–º, –µ—Å—Ç—å –ª–∏ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∑–∞ –Ω–µ–¥–µ–ª—é.)

## –°—Ç–∞—Ç—É—Å –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º
* –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ 1 ‚Äì —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å, –∫–ª—é—á–µ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è, –ø—Ä–æ–±–ª–µ–º—ã.
* –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ 2 ‚Äì –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –∏ —Ç.–¥.

## –ö–ª—é—á–µ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –Ω–µ–¥–µ–ª–∏
* (–ß—Ç–æ –±—ã–ª–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∏–ª–∏ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ.)

## –ü—Ä–æ–±–ª–µ–º—ã –∏ –±–ª–æ–∫–µ—Ä—ã
* (–ö–∞–∫–∏–µ –∑–∞–¥–∞—á–∏ —Å—Ç–æ–ø–æ—Ä—è—Ç—Å—è –∏ –ø–æ—á–µ–º—É, –∫–æ–≥–æ –∏–ª–∏ —á–µ–≥–æ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç.)

## –ü–ª–∞–Ω –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é –Ω–µ–¥–µ–ª—é
* (–°–ø–∏—Å–æ–∫ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ü–µ–ª–µ–π –∏ –æ–∂–∏–¥–∞–µ–º—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.)

## Action items
| –ó–∞–¥–∞—á–∞ | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ä–æ–∫ |
|--------|---------------|------|
| ...    | ...           | ...  |

(–ï—Å–ª–∏ —Å—Ä–æ–∫ –Ω–µ –Ω–∞–∑–≤–∞–Ω, –ø–∏—à–∏ "–Ω–µ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω").""",
    "–ò–Ω—Ü–∏–¥–µ–Ω—Ç / –ü–æ—Å—Ç–º–æ—Ä—Ç–µ–º": """–¢–≤–æ—è —Ä–æ–ª—å: —Ñ–∞—Å–∏–ª–∏—Ç–∞—Ç–æ—Ä —Ä–∞–∑–±–æ—Ä–∞ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞, –æ—Ñ–æ—Ä–º–ª—è—é—â–∏–π –ø–æ—Å—Ç–º–æ—Ä—Ç–µ–º –ø–æ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º–µ.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –ß–µ—Ç–∫–æ —Ä–∞–∑–¥–µ–ª—è–π —Ñ–∞–∫—Ç—ã, –≤–µ—Ä—Å–∏–∏ –∏ –≤—ã–≤–æ–¥—ã.
2. –ù–µ –¥–æ–±–∞–≤–ª—è–π –≥–∏–ø–æ—Ç–µ–∑, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ –±—ã–ª–æ –≤ –æ–±—Å—É–∂–¥–µ–Ω–∏–∏.
3. –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ –∫–∞–∫–æ–º—É-—Ç–æ —ç—Ç–∞–ø—É –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç, –ø–æ–º–µ—á–∞–π "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö".

–§–û–†–ú–ê–¢:
# –ü–æ—Å—Ç–º–æ—Ä—Ç–µ–º –ø–æ –∏–Ω—Ü–∏–¥–µ–Ω—Ç—É {date}

## –û–ø–∏—Å–∞–Ω–∏–µ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
(–ß—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ, –∫–æ–≥–¥–∞, –∫–∞–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã –∏ –∫–ª–∏–µ–Ω—Ç—ã –±—ã–ª–∏ –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã.)

## –•—Ä–æ–Ω–æ–ª–æ–≥–∏—è
(–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–ª—é—á–µ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –ø–æ –≤—Ä–µ–º–µ–Ω–∏: –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ, —ç—Å–∫–∞–ª–∞—Ü–∏—è, –ø–æ–ø—ã—Ç–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è, —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.)

## –ü—Ä–∏—á–∏–Ω—ã
* –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏—á–∏–Ω—ã: ...
* –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã: ...

## –í–ª–∏—è–Ω–∏–µ
* (–û–ø–∏—Å–∞–Ω–∏–µ –≤–ª–∏—è–Ω–∏—è –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –±–∏–∑–Ω–µ—Å, –∫–æ–º–∞–Ω–¥—É. –ï—Å–ª–∏ –µ—Å—Ç—å ‚Äì –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–æ—á–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏.)

## –ü—Ä–∏–Ω—è—Ç—ã–µ –º–µ—Ä—ã
* (–ß—Ç–æ —É–∂–µ —Å–¥–µ–ª–∞–Ω–æ –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–π.)

## –ü–ª–∞–Ω –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è
| –ú–µ—Ä–∞           | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ä–æ–∫ |
|----------------|---------------|------|
| ...            | ...           | ...  |

(–¢–æ–ª—å–∫–æ –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω—ã–µ –º–µ—Ä—ã. –ï—Å–ª–∏ —Å—Ä–æ–∫ –Ω–µ –Ω–∞–∑–≤–∞–Ω ‚Äì "–Ω–µ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω").""",
    "–û–±—É—á–µ–Ω–∏–µ / –í–µ–±–∏–Ω–∞—Ä": """–¢–≤–æ—è —Ä–æ–ª—å: –º–µ—Ç–æ–¥–∏—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Å–ø–µ–∫—Ç –æ–±—É—á–∞—é—â–µ–≥–æ –≤–µ–±–∏–Ω–∞—Ä–∞ –∏–ª–∏ –ª–µ–∫—Ü–∏–∏.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –°–æ—Ö—Ä–∞–Ω—è–π —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∑–∞–Ω—è—Ç–∏—è: –∏–∑ –∫–∞–∫–∏—Ö –±–ª–æ–∫–æ–≤ –æ–Ω–æ —Å–æ—Å—Ç–æ—è–ª–æ.
2. –û—Ç–¥–µ–ª—è–π –∫–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏ –æ—Ç –ø—Ä–∏–º–µ—Ä–æ–≤ –∏ —á–∞—Å—Ç–Ω—ã—Ö –∏—Å—Ç–æ—Ä–∏–π.
3. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö "—Å–æ–≤–µ—Ç–æ–≤" –∏ "–ª–∞–π—Ñ—Ö–∞–∫–æ–≤" –æ—Ç —Å–µ–±—è.

–§–û–†–ú–ê–¢:
# –ö–æ–Ω—Å–ø–µ–∫—Ç –≤–µ–±–∏–Ω–∞—Ä–∞ {date}

## –¢–µ–º–∞ –∏ —Ü–µ–ª—å
(–û —á–µ–º –±—ã–ª–æ –∑–∞–Ω—è—Ç–∏–µ –∏ –∫–∞–∫–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ö–æ—Ç–µ–ª–∏ –¥–æ—Å—Ç–∏—á—å.)

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞–Ω—è—Ç–∏—è
* –ë–ª–æ–∫ 1 ‚Äì –∫—Ä–∞—Ç–∫–æ, –æ —á–µ–º —ç—Ç–æ—Ç –±–ª–æ–∫.
* –ë–ª–æ–∫ 2 ‚Äì –∏ —Ç.–¥.

## –ö–ª—é—á–µ–≤—ã–µ —Ç–µ–∑–∏—Å—ã
* (–û—Å–Ω–æ–≤–Ω—ã–µ –º—ã—Å–ª–∏, –ø—Ä–∞–≤–∏–ª–∞, –ø–æ–¥—Ö–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤–∞–∂–Ω–æ –∑–∞–ø–æ–º–Ω–∏—Ç—å.)

## –ü—Ä–∏–º–µ—Ä—ã –∏ –∫–µ–π—Å—ã
* (–ü—Ä–∏–≤–µ–¥–µ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã —Å –∫—Ä–∞—Ç–∫–∏–º –ø–æ—è—Å–Ω–µ–Ω–∏–µ–º, —á–µ–º—É –æ–Ω–∏ —É—á–∞—Ç.)

## –ü—Ä–∞–∫—Ç–∏–∫–∞ –∏ –∑–∞–¥–∞–Ω–∏—è
* (–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è, —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è, –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —à–∞–≥–∏, –µ—Å–ª–∏ –æ–Ω–∏ –æ–∑–≤—É—á–µ–Ω—ã.)

## –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –∏ —Å—Å—ã–ª–∫–∏
* (–£–ø–æ–º—è–Ω—É—Ç—ã–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏, –¥–æ–∫—É–º–µ–Ω—Ç—ã, —Ä–µ—Å—É—Ä—Å—ã, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å –≤ —Ä–µ—á–∏.)""",
    "–Æ—Ä–∏–¥–∏—á–µ—Å–∫–æ–µ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ": """–¢–≤–æ—è —Ä–æ–ª—å: –ø–æ–º–æ—â–Ω–∏–∫ —é—Ä–∏—Å—Ç–∞ –∏–ª–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞–º, –æ—Ñ–æ—Ä–º–ª—è—é—â–∏–π –∏—Ç–æ–≥ –æ–±—Å—É–∂–¥–µ–Ω–∏—è –ø–æ –¥–æ–≥–æ–≤–æ—Ä—É.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –§–∏–∫—Å–∏—Ä—É–π —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏ —É—Å–ª–æ–≤–∏–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±–ª–∏–∑–∫–æ –∫ —Ç–æ–º—É, –∫–∞–∫ –æ–Ω–∏ –ø—Ä–æ–∑–≤—É—á–∞–ª–∏.
2. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Å—É–º–º—ã, —Å—Ä–æ–∫–∏, —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏.
3. –û—Ç–¥–µ–ª—è–π —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –æ—Ç —Å–ø–æ—Ä–Ω—ã—Ö –∏ –æ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π.

–§–û–†–ú–ê–¢:
# –û–±—Å—É–∂–¥–µ–Ω–∏–µ –¥–æ–≥–æ–≤–æ—Ä–∞ {date}

## –¢–µ–º–∞ –∏ –¥–æ–∫—É–º–µ–Ω—Ç—ã
(–ö–∞–∫–æ–π –¥–æ–≥–æ–≤–æ—Ä –∏–ª–∏ –ø–∞–∫–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –æ–±—Å—É–∂–¥–∞–µ—Ç—Å—è, –º–µ–∂–¥—É –∫–µ–º.)

## –ö–ª—é—á–µ–≤—ã–µ —É—Å–ª–æ–≤–∏—è
* –ü—Ä–µ–¥–º–µ—Ç –¥–æ–≥–æ–≤–æ—Ä–∞: ...
* –°—Ä–æ–∫–∏: ...
* –°—Ç–æ–∏–º–æ—Å—Ç—å –∏ –ø–æ—Ä—è–¥–æ–∫ —Ä–∞—Å—á–µ—Ç–æ–≤: ...
* –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∏ —à—Ç—Ä–∞—Ñ—ã: ...
* –ü—Ä–æ—á–∏–µ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è: ...

## –°–ø–æ—Ä–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã
* (–ü–æ –∫–∞–∫–∏–º –ø—É–Ω–∫—Ç–∞–º –Ω–µ –ø—Ä–∏—à–ª–∏ –∫ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–º—É —Å–æ–≥–ª–∞—Å–∏—é, –∫–∞–∫–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å—Ç–æ—Ä–æ–Ω.)

## –†–∏—Å–∫–∏ –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
* (–û–∑–≤—É—á–µ–Ω–Ω—ã–µ —Ä–∏—Å–∫–∏, –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ –∏—Ö —Å–Ω–∏–∂–µ–Ω–∏—é, –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏.)

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏
| –®–∞–≥                          | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ä–æ–∫ |
|-----------------------------|---------------|------|
| –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –Ω–æ–≤—É—é —Ä–µ–¥–∞–∫—Ü–∏—é  | ...           | ...  |
| –°–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å —Å —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ–º  | ...           | ...  |

(–¢–æ–ª—å–∫–æ —è–≤–Ω–æ –æ–∑–≤—É—á–µ–Ω–Ω—ã–µ —à–∞–≥–∏.)""",
    "–ü–æ–¥–¥–µ—Ä–∂–∫–∞ / –ö–ª–∏–µ–Ω—Ç—Å–∫–∏–π –∫–µ–π—Å": """–¢–≤–æ—è —Ä–æ–ª—å: –∞–Ω–∞–ª–∏—Ç–∏–∫ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏–ª–∏ customer success, –∫–æ—Ç–æ—Ä—ã–π –æ—Ñ–æ—Ä–º–ª—è–µ—Ç —Ä–∞–∑–±–æ—Ä –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ –∫–µ–π—Å–∞ –ø–æ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º–µ —Å–æ–∑–≤–æ–Ω–∞.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –§–∏–∫—Å–∏—Ä—É–π —Ñ–∞–∫—Ç—ã: –∫–∞–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞, –≤ –∫–∞–∫–æ–π —Å—Ä–µ–¥–µ, —Å –∫–∞–∫–∏–º–∏ —Å–∏–º–ø—Ç–æ–º–∞–º–∏.
2. –ß–µ—Ç–∫–æ —Ä–∞–∑–¥–µ–ª—è–π —Ç–æ, —á—Ç–æ —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ, –∏ —Ç–æ, —á—Ç–æ –æ—Å—Ç–∞–ª–æ—Å—å –≥–∏–ø–æ—Ç–µ–∑–æ–π.
3. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Ä–µ—à–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –±—ã–ª–∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω—ã —Å –∫–ª–∏–µ–Ω—Ç–æ–º.

–§–û–†–ú–ê–¢:
# –ö–ª–∏–µ–Ω—Ç—Å–∫–∏–π –∫–µ–π—Å {date}

## –ö–ª–∏–µ–Ω—Ç –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç
(–ö—Ç–æ –∫–ª–∏–µ–Ω—Ç, –∫–∞–∫–æ–π –ø—Ä–æ–¥—É–∫—Ç –∏–ª–∏ —É—Å–ª—É–≥–∞ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, –≤–∞–∂–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è, –µ—Å–ª–∏ —É–ø–æ–º–∏–Ω–∞–ª–∏—Å—å.)

## –û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã
* (–ö–∞–∫ –∫–ª–∏–µ–Ω—Ç –æ–ø–∏—Å—ã–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É: —Å–∏–º–ø—Ç–æ–º—ã, —á–∞—Å—Ç–æ—Ç–∞, –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –±–∏–∑–Ω–µ—Å.)

## –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
* (–ß—Ç–æ —É–∂–µ –ø—Ä–æ–≤–µ—Ä–∏–ª–∏, –∫–∞–∫–∏–µ –≥–∏–ø–æ—Ç–µ–∑—ã –∏—Å–∫–ª—é—á–∏–ª–∏, –∫–∞–∫–∏–µ –æ—Å—Ç–∞–ª–∏—Å—å.)

## –†–µ—à–µ–Ω–∏–µ –∏ –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
* (–ö–∞–∫–æ–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–µ –∏–ª–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ, –¥–æ —á–µ–≥–æ –¥–æ–≥–æ–≤–æ—Ä–∏–ª–∏—Å—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º.)

## –û—Ç–∫—Ä—ã—Ç—ã–µ –∑–∞–¥–∞—á–∏ –∏ —ç—Å–∫–∞–ª–∞—Ü–∏–∏
| –ó–∞–¥–∞—á–∞              | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ç–∞—Ç—É—Å          |
|---------------------|---------------|-----------------|
| ...                 | ...           | ...             |

(–°—Ç–∞—Ç—É—Å, –Ω–∞–ø—Ä–∏–º–µ—Ä: "–≤ —Ä–∞–±–æ—Ç–µ", "–æ–∂–∏–¥–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞", "—ç—Å–∫–∞–ª–∏—Ä–æ–≤–∞–Ω–æ". –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ —Å—Ç–∞—Ç—É—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ —è–≤–Ω–æ —Å–ª–µ–¥—É—é—Ç –∏–∑ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—ã.)""",
    "–ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–∞—è –±–µ—Å–µ–¥–∞ –∫–æ–ª–ª–µ–≥": """–¢–≤–æ—è —Ä–æ–ª—å: –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Å–µ–∫—Ä–µ—Ç–∞—Ä—å –∫–æ–º–∞–Ω–¥—ã.
–ó–∞–¥–∞—á–∞: –∏–∑ –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–æ–π –±–µ—Å–µ–¥—ã –∫–æ–ª–ª–µ–≥ —Å–¥–µ–ª–∞—Ç—å –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–æ–Ω—Å–ø–µ–∫—Ç, –ø—Ä–∏–≥–æ–¥–Ω—ã–π –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –≤ —á–∞—Ç –∏–ª–∏ –ø–æ–¥—à–∏–≤–∫–∏ –≤ –ø—Ä–æ–µ–∫—Ç.

–û–ë–©–ò–ï –ü–†–ê–í–ò–õ–ê:
1. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Ñ–∞–∫—Ç—ã, —Ä–µ—à–µ–Ω–∏—è, —Å—Ä–æ–∫–∏ –∏ —Å—É–º–º—ã, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ –±—ã–ª–æ –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ.
2. –û—Ç–¥–µ–ª—è–π –ª–∏—á–Ω—ã–µ —Ä–µ–º–∞—Ä–∫–∏, —à—É—Ç–∫–∏ –∏ –±—ã—Ç–æ–≤—ã–µ —Ç–µ–º—ã –æ—Ç —Ä–∞–±–æ—á–∏—Ö –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç–µ–π.
3. –õ–∏—á–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ (—Å–µ–º—å—è, –∑–¥–æ—Ä–æ–≤—å–µ –∏ —Ç.–ø.) –Ω–µ –ø–µ—Ä–µ—Å–∫–∞–∑—ã–≤–∞–π, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Ä–∞–±–æ—Ç—É.
4. –ï—Å–ª–∏ –≤ –±–µ—Å–µ–¥–µ –Ω–µ—Ç —è–≤–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π, —á–µ—Å—Ç–Ω–æ —Ñ–∏–∫—Å–∏—Ä—É–π —ç—Ç–æ, –Ω–µ –¥–æ—Ñ–∞–Ω—Ç–∞–∑–∏—Ä—É–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.
5. –ù–µ –æ–ø–∏—Å—ã–≤–∞–π –ø—Ä–æ—Ü–µ—Å—Å –∞–Ω–∞–ª–∏–∑–∞, –≤—ã–≤–æ–¥–∏ —Ç–æ–ª—å–∫–æ –∏—Ç–æ–≥–æ–≤—ã–π –∫–æ–Ω—Å–ø–µ–∫—Ç.

–§–û–†–ú–ê–¢:
# –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–∞—è –±–µ—Å–µ–¥–∞ –∫–æ–ª–ª–µ–≥ {date}

## –ö–æ–Ω—Ç–µ–∫—Å—Ç
(–ö—Ç–æ –ø—Ä–∏–º–µ—Ä–Ω–æ —É—á–∞—Å—Ç–≤–æ–≤–∞–ª, –≤–æ–∫—Ä—É–≥ –∫–∞–∫–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –∏–ª–∏ —Ç–µ–º—ã —à–ª–∞ –±–µ—Å–µ–¥–∞, –≥–¥–µ/–≤ –∫–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –æ–±—â–∞–ª–∏—Å—å ‚Äì —á–∞—Ç, –∫—É—Ö–Ω—è, –¥–æ—Ä–æ–≥–∞ –∏ —Ç.–ø., –µ—Å–ª–∏ —ç—Ç–æ –ø–æ–Ω—è—Ç–Ω–æ –∏–∑ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—ã.)

## –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ–º—ã
* –¢–µ–º–∞ 1 ‚Äì –∫—Ä–∞—Ç–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –æ–±—Å—É–∂–¥–µ–Ω–∏—è –ø–æ –Ω–µ–π.
* –¢–µ–º–∞ 2 ‚Äì –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ.
* –î–æ–±–∞–≤—å —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–∏–º—ã–µ —Ä–∞–±–æ—á–∏–µ —Ç–µ–º—ã, –º–µ–ª–∫–∏–π –±—ã—Ç–æ–≤–æ–π —Ä–∞–∑–≥–æ–≤–æ—Ä –æ–ø—É—Å–∫–∞–π.

## –ü—Ä–∏–Ω—è—Ç—ã–µ –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
* (–¢–æ, –æ —á–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∏ —è–≤–Ω–æ —Å–∫–∞–∑–∞–ª–∏ "–¥–∞–≤–∞–π —Ç–∞–∫ –∏ —Å–¥–µ–ª–∞–µ–º", "–æ–∫, –¥–æ–≥–æ–≤–æ—Ä–∏–ª–∏—Å—å", "—Å–¥–µ–ª–∞–µ–º –≤–æ—Ç —Ç–∞–∫". –§–æ—Ä–º—É–ª–∏—Ä—É–π –∫–∞–∫ —Ä–µ—à–µ–Ω–∏—è.)

## –ò–¥–µ–∏ "–Ω–∞ –ø–æ–¥—É–º–∞—Ç—å"
* (–ò–¥–µ–∏ –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ–∑–≤—É—á–∞–ª–∏, –Ω–æ –ø–æ –Ω–∏–º –Ω–µ –±—ã–ª–æ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è, –ª–∏–±–æ –æ—Ç–ª–æ–∂–µ–Ω—ã "–Ω–∞–¥–æ –ø–æ–¥—É–º–∞—Ç—å".)

## –†–∏—Å–∫–∏ –∏ —Å–æ–º–Ω–µ–Ω–∏—è
* (–û —á–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∏ –±–µ—Å–ø–æ–∫–æ—è—Ç—Å—è: –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è, –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏.)

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏
| –ó–∞–¥–∞—á–∞ | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ä–æ–∫ |
|--------|---------------|------|
| ...    | ...           | ...  |

(–í —Ç–∞–±–ª–∏—Ü—É –∑–∞–Ω–æ—Å–∏ —Ç–æ–ª—å–∫–æ —Ç–µ —à–∞–≥–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–æ–∑–≤—É—á–∞–ª–∏. –ï—Å–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å –∏–ª–∏ —Å—Ä–æ–∫ –Ω–µ –Ω–∞–∑–≤–∞–Ω—ã ‚Äì –∏—Å–ø–æ–ª—å–∑—É–π "–Ω–µ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω").

–°—Ç–∏–ª—å: —Å–ø–æ–∫–æ–π–Ω—ã–π, –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π, –±–µ–∑ –∂–∞—Ä–≥–æ–Ω–∞ –∏ –æ—Ü–µ–Ω–æ–∫. –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–æ—Å—Ç—å –±–µ—Å–µ–¥—ã –º–æ–∂–Ω–æ –∫—Ä–∞—Ç–∫–æ –ø–µ—Ä–µ–¥–∞—Ç—å –≤ —Ä–∞–∑–¥–µ–ª–µ "–ö–æ–Ω—Ç–µ–∫—Å—Ç", –Ω–æ —Å–∞–º –æ—Ç—á–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–µ–ª–æ–≤—ã–º –∏ –ø–æ–Ω—è—Ç–Ω—ã–º –¥–ª—è —Ç–µ—Ö, –∫—Ç–æ –≤ –±–µ—Å–µ–¥–µ –Ω–µ —É—á–∞—Å—Ç–≤–æ–≤–∞–ª.)"""
}

OLLAMA_MODELS = {
    "Weak (CPU / <8GB VRAM)": [
        {"name": "Llama 3.2 3B", "id": "llama3.2:3b"},
        {"name": "Qwen 3 8B", "id": "qwen3:8b"},
        {"name": "DeepSeek-R1 7B", "id": "deepseek-r1:7b"},
        {"name": "Mistral 7B", "id": "mistral"},
    ],
    "Medium (16-20GB VRAM)": [
        {"name": "GPT-OSS 20B", "id": "gpt-oss:20b"},
        {"name": "Qwen 3 14B", "id": "qwen3:14b"},
        {"name": "DeepSeek-R1 14B", "id": "deepseek-r1:14b"},
        {"name": "Gemma 3 27B", "id": "gemma3:27b"},
    ],
    "Pro (>20GB VRAM)": [
        {"name": "Qwen 3 32B", "id": "qwen3:32b"},
        {"name": "DeepSeek-R1 32B", "id": "deepseek-r1:32b"},
        {"name": "Llama 3.1 70B", "id": "llama3.1:70b"},
        {"name": "DeepSeek-R1 671B", "id": "deepseek-r1:671b"},
    ],
}

DEFAULT_SETTINGS = {
    "hf_token": "",
    "deepgram_key": "",
    "keywords": "",
    "processing_mode": "cloud",          # cloud | local
    "cloud_use_mp3": True,
    "local_model_size": "base",

    # "local_compute": "int8",  # Removed, auto-detected
    "llm_provider": "openrouter",       # openrouter | local
    "or_key": "",
    "or_model": "gpt-4.1-mini",
    "local_model": "qwen2.5:7b",
    "local_url": "http://localhost:11434/v1/chat/completions",
    "llm_token_limit": 12000,       # –ü–æ—Ä–æ–≥ —Ç–æ–∫–µ–Ω–æ–≤
    "enable_token_limit": True,     # [NEW] –í–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏–º–∏—Ç–∞ —Ç–æ–∫–µ–Ω–æ–≤
    "chunk_minutes": 55,            # –†–∞–∑–º–µ—Ä —á–∞—Å—Ç–∏
    "force_time_split": False,      # [NEW] –í—Å–µ–≥–¥–∞ —Ä–∞–∑–±–∏–≤–∞—Ç—å –Ω–∞ —á–∞—Å—Ç–∏ (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –¥–ª–∏–Ω—ã)
    "current_prompt_name": "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π",
    "system_prompt": BUILTIN_PROMPTS["–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π"],
    "custom_prompts": {},
    "use_gdrive": False,
    "keep_local": True,
    "input_device": "Default",
    "rec_format": "wav",                # wav | mp3 (–∏—Ç–æ–≥–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç)
    "save_txt": True,
    "remove_silence": False,
    "save_docx": True,
}

ENROLL_TEXT = (
    "–ü—Ä–∏–≤–µ—Ç! –ú–µ–Ω—è –∑–æ–≤—É—Ç {name}. –Ø –¥–∞—é —Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞ –∑–∞–ø–∏—Å—å –º–æ–µ–≥–æ –≥–æ–ª–æ—Å–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ —Å–ª–µ–ø–∫–∞. "
    "–°—Ç–æ, –¥–≤–µ—Å—Ç–∏, —Ç—Ä–∏—Å—Ç–∞, —á–µ—Ç—ã—Ä–µ—Å—Ç–∞, –ø—è—Ç—å—Å–æ—Ç. "
    "–í —á–∞—â–∞—Ö —é–≥–∞ –∂–∏–ª –±—ã —Ü–∏—Ç—Ä—É—Å? –î–∞, –Ω–æ —Ñ–∞–ª—å—à–∏–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä! "
    "–ê—ç—Ä–æ—Ñ–æ—Ç–æ—Å—ä—ë–º–∫–∞ –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ —É–∂–µ –ø—Ä–æ–≤–µ–¥–µ–Ω–∞. "
    "–ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: —Ä–∞–∑, –¥–≤–∞, —Ç—Ä–∏. –ó–∞–ø–∏—Å—å –º–æ–∂–Ω–æ –∑–∞–≤–µ—Ä—à–∞—Ç—å."
)

RETRAIN_TEXT = (
    "–≠—Ç–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–ø–∏—Å—å –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –º–æ–µ–≥–æ –≥–æ–ª–æ—Å–∞. "
    "–®–µ—Å—Ç—å—Å–æ—Ç, —Å–µ–º—å—Å–æ—Ç, –≤–æ—Å–µ–º—å—Å–æ—Ç, –¥–µ–≤—è—Ç—å—Å–æ—Ç, —Ç—ã—Å—è—á–∞. "
    "–®–∏—Ä–æ–∫–∞—è —ç–ª–µ–∫—Ç—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —é–∂–Ω—ã—Ö –≥—É–±–µ—Ä–Ω–∏–π –¥–∞—Å—Ç –º–æ—â–Ω—ã–π —Ç–æ–ª—á–æ–∫ –ø–æ–¥—ä—ë–º—É —Å–µ–ª—å—Å–∫–æ–≥–æ —Ö–æ–∑—è–π—Å—Ç–≤–∞. "
    "–≠—Ö, —á—É–∂–∞–∫, –æ–±—â–∏–π —Å—ä—ë–º —Ü–µ–Ω —à–ª—è–ø (—é—Ñ—Ç—å) ‚Äî –≤–¥—Ä—ã–∑–≥! "
    "–¢–µ–ø–µ—Ä—å —Å–∏—Å—Ç–µ–º–∞ –¥–æ–ª–∂–Ω–∞ —É–∑–Ω–∞–≤–∞—Ç—å –º–µ–Ω—è –Ω–∞–º–Ω–æ–≥–æ –ª—É—á—à–µ."
)

ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("blue")


# --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---

def sanitize_filename(name: str) -> str:
    return re.sub(r'[<>:"/\\|?*]', "_", str(name)).strip() or "untitled"


def cosine_distance(e1, e2) -> float:
    if len(e1.shape) == 1:
        e1 = e1.reshape(1, -1)
    if len(e2.shape) == 1:
        e2 = e2.reshape(1, -1)
    return float(cdist(e1, e2, metric="cosine")[0, 0])


def fetch_openrouter_models():
    try:
        resp = requests.get("https://openrouter.ai/api/v1/models")
        if resp.status_code == 200:
            data = resp.json()
            return [m["id"] for m in data.get("data", [])]
    except Exception:
        pass
    return []


# --- –ú–ï–ù–ï–î–ñ–ï–† –ù–ê–°–¢–†–û–ï–ö ---

class ConfigManager:
    def __init__(self):
        self.data = self._load()

    def _load(self):
        if not os.path.exists(SETTINGS_FILE):
            self._save_data(DEFAULT_SETTINGS)
            return DEFAULT_SETTINGS.copy()
        try:
            with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
            for k, v in DEFAULT_SETTINGS.items():
                if k not in d:
                    d[k] = v
            return d
        except Exception:
            return DEFAULT_SETTINGS.copy()

    def _save_data(self, d):
        with open(SETTINGS_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, indent=4, ensure_ascii=False)

    def save(self):
        self._save_data(self.data)

    def get(self, key, default=None):
        return self.data.get(key, default)

    def set(self, key, value):
        self.data[key] = value


config = ConfigManager()


# --- FFmpeg ---

class FFmpegInstaller:
    @staticmethod
    def is_installed():
        try:
            subprocess.run(
                ["ffmpeg", "-version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False,
            )
            return True
        except Exception:
            return False

    @staticmethod
    def install(log_cb=print):
        url = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
        log_cb("–°–∫–∞—á–∏–≤–∞–Ω–∏–µ FFmpeg...")
        try:
            r = requests.get(url, stream=True)
            r.raise_for_status()
        except Exception as e:
            log_cb(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ FFmpeg: {e}")
            return

        with BytesIO(r.content) as b, zipfile.ZipFile(b) as z:
            folder = [n for n in z.namelist() if n.endswith("bin/")][0]
            for f in z.namelist():
                if f.startswith(folder) and f.endswith(".exe"):
                    z.extract(f, ".")
                    src = os.path.join(".", f)
                    dst = os.path.join(".", os.path.basename(f))
                    shutil.move(src, dst)
        log_cb("FFmpeg —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")


class AudioHelper:
    @staticmethod
    def get_devices():
        try:
            return [
                f"{i}: {d['name']}"
                for i, d in enumerate(sd.query_devices())
                if d.get("max_input_channels", 0) > 0
            ]
        except Exception:
            return []


# --- –†–ï–ö–û–†–î–ï–† –ê–£–î–ò–û ---

class AudioRecorder:
    """
    –ü–∏—à–µ–º –≤—Å–µ–≥–¥–∞ –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π WAV-—Ñ–∞–π–ª, –ø–æ—Ç–æ–º –ø–æ –≤—ã–±–æ—Ä—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ WAV –∏–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ MP3.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–∞—É–∑—É –∏ –∑–∞–º–µ—Ä —É—Ä–æ–≤–Ω—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏.
    """


    def _strip_silence_ffmpeg(self, input_path: str, output_path: str) -> bool:
        """
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç FFmpeg filter 'silenceremove' –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ç–∏—à–∏–Ω—ã.
        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: —É–¥–∞–ª—è—Ç—å –≤—Å—ë, —á—Ç–æ —Ç–∏—à–µ -40dB –∏ –¥–ª–∏—Ç—Å—è –¥–æ–ª—å—à–µ 1 —Å–µ–∫.
        """
        if not FFmpegInstaller.is_installed():
            return False
            
        try:
            # stop_periods=-1 : —É–¥–∞–ª—è—Ç—å –≤—Å–µ –ø–µ—Ä–∏–æ–¥—ã —Ç–∏—à–∏–Ω—ã
            # stop_duration=1 : —Å—á–∏—Ç–∞—Ç—å —Ç–∏—à–∏–Ω–æ–π –∫—É—Å–∫–∏ > 1 —Å–µ–∫
            # stop_threshold=-40dB : –ø–æ—Ä–æ–≥ –≥—Ä–æ–º–∫–æ—Å—Ç–∏
            cmd = [
                "ffmpeg", "-y", "-i", input_path,
                "-af", "silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-40dB",
                output_path
            ]
            # –ó–∞–ø—É—Å–∫–∞–µ–º –±–µ–∑ –æ—Ç–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ –∫–æ–Ω—Å–æ–ª–∏
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                
            subprocess.run(
                cmd, 
                stdout=subprocess.DEVNULL, 
                stderr=subprocess.DEVNULL,
                check=True,
                startupinfo=startupinfo
            )
            return True
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ VAD FFmpeg: {e}")
            return False

    def stop(self, force_wav: bool = False) -> bool:
        if not self.recording:
            return False

        self.recording = False
        self.paused = False
        self.current_volume = 0.0

        try:
            if self.stream:
                self.stream.stop()
                self.stream.close()
        except Exception:
            pass

        if self.writer_thread:
            self.writer_thread.join()

        if not self.temp_filename or not os.path.exists(self.temp_filename):
            return False

        final_fmt = config.get("rec_format")
        if force_wav:
            final_fmt = "wav"

        try:
            dirpath = os.path.dirname(self.final_target)
            if dirpath:
                os.makedirs(dirpath, exist_ok=True)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —É–¥–∞–ª—è—Ç—å —Ç–∏—à–∏–Ω—É
            source_file = self.temp_filename
            vad_applied = False
            
            if config.get("remove_silence"):
                # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Ñ–∞–π–ª –±–µ–∑ —Ç–∏—à–∏–Ω—ã
                vad_file = self.temp_filename.replace(".wav", "_vad.wav")
                if self._strip_silence_ffmpeg(self.temp_filename, vad_file):
                    source_file = vad_file
                    vad_applied = True
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è / –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤ —Ñ–∏–Ω–∞–ª
            if final_fmt == "mp3":
                if self.final_target.endswith(".wav"):
                    self.final_target = self.final_target[:-4] + ".mp3"

                AudioSegment.from_wav(source_file).export(
                    self.final_target,
                    format="mp3",
                    bitrate="128k",
                )
            else:
                if os.path.exists(self.final_target):
                    os.remove(self.final_target)
                # –ï—Å–ª–∏ VAD —Å–æ–∑–¥–∞–≤–∞–ª –∫–æ–ø–∏—é, –ø–µ—Ä–µ–º–µ—â–∞–µ–º –µ—ë, –∏–Ω–∞—á–µ –æ—Ä–∏–≥–∏–Ω–∞–ª
                if vad_applied:
                    shutil.move(source_file, self.final_target)
                else:
                    shutil.move(source_file, self.final_target)

            # –ß–∏—Å—Ç–∫–∞ –º—É—Å–æ—Ä–∞
            if os.path.exists(self.temp_filename):
                os.remove(self.temp_filename)
            if vad_applied and os.path.exists(source_file):
                # –ï—Å–ª–∏ –≤–¥—Ä—É–≥ move –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª –∏–ª–∏ –æ—Å—Ç–∞–ª—Å—è —Ö–≤–æ—Å—Ç
                try: os.remove(source_file)
                except: pass

            return True
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞—É–¥–∏–æ: {e}")
            return False

    def __init__(self):
        self.recording = False
        self.paused = False  # –§–ª–∞–≥ –ø–∞—É–∑—ã
        self.queue = queue.Queue()
        self.stream = None
        self.writer_thread = None
        self.temp_filename = None
        self.final_target = None
        self.current_volume = 0.0  # –¢–µ–∫—É—â–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å (0.0 ... 1.0)

    def _callback(self, indata, frames, time_info, status):
        if self.recording:
            # 1. –†–∞—Å—á–µ—Ç –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ (RMS)
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º numpy –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–¥—Å—á–µ—Ç–∞ —Å—Ä–µ–¥–Ω–µ–≥–æ
            volume = np.linalg.norm(indata) / np.sqrt(len(indata))
            # –£—Å–∏–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–ª–æ—Å–∫–∞ –ø—Ä—ã–≥–∞–ª–∞ –∑–∞–º–µ—Ç–Ω–µ–µ
            self.current_volume = min(volume * 5, 1.0) 

            # 2. –ï—Å–ª–∏ –Ω–µ –Ω–∞ –ø–∞—É–∑–µ ‚Äî –ø–∏—à–µ–º –¥–∞–Ω–Ω—ã–µ
            if not self.paused:
                self.queue.put(indata.copy())

    def _writer(self):
        with sf.SoundFile(
            self.temp_filename,
            mode="w",
            samplerate=16000,
            channels=1
        ) as file:
            while self.recording or not self.queue.empty():
                try:
                    data = self.queue.get(timeout=0.5)
                    file.write(data)
                except queue.Empty:
                    continue

    def start(self, target_filename: str):
        if self.recording:
            return

        self.final_target = target_filename
        self.temp_filename = f"temp_rec_{uuid.uuid4().hex}.wav"
        self.recording = True
        self.paused = False
        self.current_volume = 0.0

        dev_conf = config.get("input_device")
        dev_id = None
        if dev_conf and ":" in dev_conf:
            try:
                dev_id = int(dev_conf.split(":")[0])
            except ValueError:
                dev_id = None

        try:
            self.stream = sd.InputStream(
                samplerate=16000,
                channels=1,
                callback=self._callback,
                device=dev_id,
            )
            self.stream.start()
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∑–∞–ø–∏—Å–∏: {e}")
            self.recording = False
            return

        self.writer_thread = threading.Thread(target=self._writer, daemon=True)
        self.writer_thread.start()
    
    def toggle_pause(self):
        """–ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å –ø–∞—É–∑—ã"""
        if self.recording:
            self.paused = not self.paused
            return self.paused
        return False

    def stop(self, force_wav: bool = False) -> bool:
        if not self.recording:
            return False

        self.recording = False
        self.paused = False
        self.current_volume = 0.0

        try:
            if self.stream:
                self.stream.stop()
                self.stream.close()
        except Exception:
            pass

        if self.writer_thread:
            self.writer_thread.join()

        if not self.temp_filename or not os.path.exists(self.temp_filename):
            return False

        final_fmt = config.get("rec_format")
        if force_wav:
            final_fmt = "wav"

        try:
            dirpath = os.path.dirname(self.final_target)
            if dirpath:
                os.makedirs(dirpath, exist_ok=True)

            if final_fmt == "mp3":
                if self.final_target.endswith(".wav"):
                    self.final_target = self.final_target[:-4] + ".mp3"

                AudioSegment.from_wav(self.temp_filename).export(
                    self.final_target,
                    format="mp3",
                    bitrate="128k",
                )
                os.remove(self.temp_filename)
            else:
                if os.path.exists(self.final_target):
                    os.remove(self.final_target)
                shutil.move(self.temp_filename, self.final_target)

            return True
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞—É–¥–∏–æ: {e}")
            return False


# --- AI –ë–õ–û–ö: STT + –î–ò–ê–†–ò–ó–ê–¶–ò–Ø ---

class AudioPlayer:
    """
    –ü—Ä–æ–∏–≥—Ä—ã–≤–∞—Ç–µ–ª—å –∞—É–¥–∏–æ –Ω–∞ –±–∞–∑–µ sounddevice + pydub.
    –ü–æ–∑–≤–æ–ª—è–µ—Ç –∏–≥—Ä–∞—Ç—å, —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –ø–∞—É–∑—É –∏ –ø–µ—Ä–µ–º–∞—Ç—ã–≤–∞—Ç—å (seek).
    """
    def __init__(self):
        self.data = None
        self.fs = 44100
        self.current_frame = 0
        self.total_frames = 0
        self.is_playing = False
        self.stream = None
        self.duration_sec = 0
        
    def load(self, path: str):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∞—É–¥–∏–æ—Ñ–∞–π–ª –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –≤ numpy array"""
        self.stop()
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Pydub –¥–ª—è —É–Ω–∏—Ñ–∏–∫–∞—Ü–∏–∏ (—á–∏—Ç–∞–µ—Ç mp3, wav, ogg...)
            seg = AudioSegment.from_file(path)
            
            # –ü—Ä–∏–≤–æ–¥–∏–º –∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—É: –º–æ–Ω–æ, 44.1kHz (–¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è)
            seg = seg.set_frame_rate(44100).set_channels(1)
            self.fs = 44100
            self.duration_sec = len(seg) / 1000.0
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ numpy float32
            # get_array_of_samples –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç array.array (int)
            samples = np.array(seg.get_array_of_samples(), dtype=np.float32)
            
            # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è (pydub –¥–∞–µ—Ç int16/int32, sounddevice —Ö–æ—á–µ—Ç float -1..1)
            # –û–±—ã—á–Ω–æ 16-–±–∏—Ç, –¥–µ–ª–∏–º –Ω–∞ 2^15
            max_val = float(1 << (8 * seg.sample_width - 1))
            self.data = samples / max_val
            
            self.total_frames = len(self.data)
            self.current_frame = 0
            return True
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–ª–µ–µ—Ä–∞: {e}")
            return False

    def _callback(self, outdata, frames, time, status):
        if not self.is_playing:
            outdata.fill(0)
            return

        chunk_size = frames
        remain = self.total_frames - self.current_frame
        
        if remain <= 0:
            # –ö–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞
            outdata.fill(0)
            self.is_playing = False
            raise sd.CallbackStop()
        
        if remain < chunk_size:
            # –ü–æ—Å–ª–µ–¥–Ω–∏–π –∫—É—Å–æ—á–µ–∫
            outdata[:remain, 0] = self.data[self.current_frame : self.current_frame + remain]
            outdata[remain:, 0] = 0
            self.current_frame += remain
        else:
            # –û–±—ã—á–Ω—ã–π –∫—É—Å–æ–∫
            outdata[:, 0] = self.data[self.current_frame : self.current_frame + chunk_size]
            self.current_frame += chunk_size

    def play(self):
        if not self.data is None and not self.is_playing:
            self.is_playing = True
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫, –µ—Å–ª–∏ –æ–Ω –º–µ—Ä—Ç–≤ –∏–ª–∏ –∑–∞–∫—Ä—ã—Ç
            if self.stream is None or not self.stream.active:
                self.stream = sd.OutputStream(
                    samplerate=self.fs,
                    channels=1,
                    callback=self._callback,
                    finished_callback=self._on_finished
                )
                self.stream.start()

    def pause(self):
        self.is_playing = False
        # –ü–æ—Ç–æ–∫ –Ω–µ —É–±–∏–≤–∞–µ–º, –ø—Ä–æ—Å—Ç–æ callback –±—É–¥–µ—Ç —Å–ª–∞—Ç—å —Ç–∏—à–∏–Ω—É –∏–ª–∏ –º—ã –µ–≥–æ –æ—Å—Ç–∞–Ω–æ–≤–∏–º
        if self.stream and self.stream.active:
            self.stream.stop()
            self.stream.close()
            self.stream = None

    def stop(self):
        self.is_playing = False
        self.current_frame = 0
        if self.stream:
            try:
                self.stream.stop()
                self.stream.close()
            except: pass
            self.stream = None

    def seek(self, seconds: float):
        if self.data is None: return
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º
        seconds = max(0, min(seconds, self.duration_sec))
        self.current_frame = int(seconds * self.fs)

    def get_pos(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—Ç–µ–∫—É—â–∞—è_—Å–µ–∫—É–Ω–¥–∞, –≤—Å–µ–≥–æ_—Å–µ–∫—É–Ω–¥)"""
        if self.data is None: return 0, 0
        curr = self.current_frame / self.fs
        return curr, self.duration_sec

    def _on_finished(self):
        self.is_playing = False

class AIProcessor:
    def __init__(self):
        self.device = None
        self._emb_model = None
        self._emb_inference = None
        self._pipeline = None
        self._whisper_model = None

    def _init_torch(self):
        if self.device:
            return
        self.device = "cuda" if torch.cuda.is_available() else "cpu"

    def _load_embedding_model(self):
        if self._emb_inference:
            return
        self._init_torch()
        from pyannote.audio import Model, Inference

        token = config.get("hf_token")
        self._emb_model = Model.from_pretrained(
            "pyannote/wespeaker-voxceleb-resnet34-LM",
            token=token,
        )
        if self.device == "cuda":
            self._emb_model.to(torch.device("cuda"))
        self._emb_inference = Inference(self._emb_model, window="whole")

    def _load_pipeline(self):
        if self._pipeline:
            return
        self._init_torch()
        # AudioDecoder is already injected by global monkeypatch
        
        from pyannote.audio import Pipeline

        token = config.get("hf_token")
        self._pipeline = Pipeline.from_pretrained(
            "pyannote/speaker-diarization-3.1",
            token=token,
        )
        self._pipeline.to(torch.device(self.device))

    def _load_whisper(self):
        if self._whisper_model:
            return
        self._init_torch()
        from faster_whisper import WhisperModel

        self._whisper_model = WhisperModel(
            config.get("local_model_size"),
            device=self.device,
            compute_type="float16" if self.device == "cuda" else "int8",
        )

    def create_embedding(self, wav_path: str):
        self._load_embedding_model()
        wave, sr = torchaudio.load(wav_path)
        return self._emb_inference({"waveform": wave, "sample_rate": sr})

    def analyze(self, path: str, voice_db: dict, log_cb, stop_event=None):
        mode = config.get("processing_mode")
        if mode == "cloud":
            return self._analyze_cloud(path, voice_db, log_cb)
        return self._analyze_local(path, voice_db, log_cb, stop_event)

    # --- –û–±–ª–∞–∫–æ (Deepgram) ---

    def _analyze_cloud(self, path: str, voice_db: dict, log_cb):
        log_cb("–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤ –æ–±–ª–∞–∫–µ (Deepgram)...")

        key = config.get("deepgram_key")
        if not key:
            raise RuntimeError("–ù–µ –∑–∞–¥–∞–Ω –∫–ª—é—á Deepgram API.")

        src_path = path
        tmp_mp3 = f"tmp_{uuid.uuid4().hex}.mp3"

        if config.get("cloud_use_mp3"):
            log_cb("–°–∂–∞—Ç–∏–µ –∞—É–¥–∏–æ –≤ MP3 –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏...")
            AudioSegment.from_file(path).export(
                tmp_mp3,
                format="mp3",
                bitrate="64k",
            )
            src_path = tmp_mp3

        url = (
            "https://api.deepgram.com/v1/listen"
            "?model=nova-2"
            "&diarize=true"
            "&smart_format=true"
            "&language=ru"
            "&punctuate=true"
        )

        keywords = config.get("keywords")
        if keywords:
            for w in keywords.split(","):
                w = w.strip()
                if w:
                    url += f"&keywords={w}:2"

        try:
            with open(src_path, "rb") as f:
                r = requests.post(
                    url,
                    headers={"Authorization": f"Token {key}"},
                    data=f,
                )
        except Exception as e:
            raise ConnectionError(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ Deepgram: {e}")

        if src_path == tmp_mp3 and os.path.exists(tmp_mp3):
            os.remove(tmp_mp3)

        if r.status_code != 200:
            raise RuntimeError(f"–û—à–∏–±–∫–∞ Deepgram: {r.text}")

        words = (
            r.json()
            .get("results", {})
            .get("channels", [{}])[0]
            .get("alternatives", [{}])[0]
            .get("words", [])
        )

        segments = []
        current = {"speaker": None, "words": [], "start": 0.0, "end": 0.0}

        for w in words:
            spk = w.get("speaker", 0)
            word = w.get("punctuated_word") or w.get("word", "")
            if (
                current["speaker"] is None
                or spk == current["speaker"]
            ) and current["words"]:
                # –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç
                current["words"].append(word)
                current["end"] = w["end"]
            else:
                # –Ω–æ–≤—ã–π —Å–ø–∏–∫–µ—Ä –∏–ª–∏ –ø–µ—Ä–≤–∞—è —Ñ—Ä–∞–∑–∞
                if current["words"]:
                    segments.append(
                        {
                            "start": current["start"],
                            "end": current["end"],
                            "label": f"–°–ø–∏–∫–µ—Ä {current['speaker']}",
                            "text": " ".join(current["words"]),
                            "audio": None,
                            "fs": 0,
                        }
                    )
                current = {
                    "speaker": spk,
                    "words": [word],
                    "start": w["start"],
                    "end": w["end"],
                }

        if current["words"]:
            segments.append(
                {
                    "start": current["start"],
                    "end": current["end"],
                    "label": f"–°–ø–∏–∫–µ—Ä {current['speaker']}",
                    "text": " ".join(current["words"]),
                    "audio": None,
                    "fs": 0,
                }
            )

        return segments, {}  # –≤–æ–æ–±–ª–∞–∫–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –ø–æ –±–∞–∑–µ –Ω–µ –¥–µ–ª–∞–µ–º

    # --- –õ–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º (PyAnnote + faster-whisper) ---

    def _analyze_local(self, path: str, voice_db: dict, log_cb, stop_event=None):
        log_cb("–õ–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º: –¥–∏–∞—Ä–∏–∑–∞—Ü–∏—è...")
        
        # –ü–†–û–í–ï–†–ö–ê –û–¢–ú–ï–ù–´
        if stop_event and stop_event.is_set(): raise OperationCancelled()
        
        self._load_pipeline()
        diar = self._pipeline(path)
        
        if stop_event and stop_event.is_set(): raise OperationCancelled()

        if isinstance(diar, Annotation):
            ann = diar
        elif hasattr(diar, "annotation"):
            ann = diar.annotation
        elif hasattr(diar, "speaker_diarization"):
            ann = diar.speaker_diarization
        else:
            raise RuntimeError(f"–ü–∞–π–ø–ª–∞–π–Ω –≤–µ—Ä–Ω—É–ª –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø: {type(diar)}")

        audio = AudioSegment.from_file(path)
        speaker_chunks = []

        os.makedirs(TEMP_DIR, exist_ok=True)

        # 1. –ù–∞—Ä–µ–∑–∫–∞ –∞—É–¥–∏–æ
        for seg, _, label in ann.itertracks(yield_label=True):
            if stop_event and stop_event.is_set(): raise OperationCancelled()
            
            start_ms = int(seg.start * 1000)
            end_ms = int(seg.end * 1000)
            if end_ms - start_ms < 500:
                continue
            chunk = audio[start_ms:end_ms]
            tmp_wav = os.path.join(TEMP_DIR, f"chunk_{uuid.uuid4().hex}.wav")
            chunk.export(tmp_wav, format="wav")
            speaker_chunks.append(
                {
                    "start": seg.start,
                    "end": seg.end,
                    "label": label,
                    "file": tmp_wav,
                }
            )

        if not speaker_chunks:
            return [], {}

        log_cb(f"–õ–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º: —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ ({len(speaker_chunks)} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤)...")
        self._load_whisper()

        segments = []
        batch_size = config.get("batch_size", 8)
        total_chunks = len(speaker_chunks)
        
        # 2. –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è —Ç–µ–∫—Å—Ç–∞ (Whisper) —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –æ—Ç–º–µ–Ω—ã
        for batch_idx in range(0, total_chunks, batch_size):
            # –ü–†–û–í–ï–†–ö–ê –û–¢–ú–ï–ù–´ –ü–ï–†–ï–î –ö–ê–ñ–î–´–ú –ü–ê–ö–ï–¢–û–ú
            if stop_event and stop_event.is_set(): 
                log_cb("–û–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–µ—Ä–≤–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
                raise OperationCancelled()

            batch = speaker_chunks[batch_idx:batch_idx + batch_size]
            batch_num = (batch_idx // batch_size) + 1
            total_batches = (total_chunks + batch_size - 1) // batch_size
            
            log_cb(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∞–∫–µ—Ç–∞ {batch_num}/{total_batches} ({len(batch)} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤)...")
            
            for ch in batch:
                # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç 16kHz
                wav, sr = torchaudio.load(ch["file"])
                if sr != 16000:
                    wav = torchaudio.functional.resample(wav, sr, 16000)
                    sr = 16000
                torchaudio.save(ch["file"], wav, sr)

                try:
                    res, info = self._whisper_model.transcribe(ch["file"], beam_size=5)
                except RuntimeError as e:
                    if "cublas" in str(e).lower() and self.device == "cuda":
                        self.device = "cpu"
                        self._whisper_model = None
                        self._load_whisper()
                        res, info = self._whisper_model.transcribe(ch["file"], beam_size=5)
                    else:
                        raise e
                text = " ".join(r.text.strip() for r in res)
                segments.append(
                    {
                        "start": ch["start"],
                        "end": ch["end"],
                        "label": ch["label"],
                        "text": text,
                        "audio": ch["file"],
                        "fs": 16000,
                    }
                )
        
        # 3. –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è (—Ç–æ–∂–µ –¥–æ–±–∞–≤–∏–º –ø—Ä–æ–≤–µ—Ä–∫—É)
        if voice_db:
            if stop_event and stop_event.is_set(): raise OperationCancelled()
            log_cb("–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —Å–ø–∏–∫–µ—Ä–æ–≤ –ø–æ –±–∞–∑–µ...")
            self._load_embedding_model()
            
            speaker_samples = {}
            for s in segments:
                lbl = s["label"]
                dur = s["end"] - s["start"]
                if lbl not in speaker_samples or dur > speaker_samples[lbl]["dur"]:
                    speaker_samples[lbl] = {"audio": s["audio"], "dur": dur}

            mapping = {}
            threshold = 0.55 

            for spk_label, data in speaker_samples.items():
                if stop_event and stop_event.is_set(): raise OperationCancelled()
                try:
                    unknown_emb = self.create_embedding(data["audio"])
                    best_name = None
                    min_dist = 100.0
                    
                    for name, db_data in voice_db.items():
                        if isinstance(db_data, dict):
                            target_emb = db_data.get("embedding")
                        else:
                            target_emb = db_data
                            
                        if target_emb is None: continue

                        dist = cosine_distance(unknown_emb, target_emb)
                        if dist < min_dist:
                            min_dist = dist
                            best_name = name
                    
                    if min_dist < threshold and best_name:
                        mapping[spk_label] = best_name
                        log_cb(f"–£–∑–Ω–∞–ª: {spk_label} -> {best_name} (—Ç–æ—á–Ω–æ—Å—Ç—å: {1-min_dist:.2f})")
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ {spk_label}: {e}")

            if mapping:
                for s in segments:
                    if s["label"] in mapping:
                        s["label"] = mapping[s["label"]]

        # 4. –°–±–æ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö
        unknown = {}
        for s in segments:
            label = s["label"]
            if label in voice_db: continue
            
            if label not in unknown:
                unknown[label] = {
                    "audio": s["audio"],
                    "fs": s["fs"],
                    "dur": s["end"] - s["start"],
                }
            else:
                if s["end"] - s["start"] > unknown[label]["dur"]:
                    unknown[label]["audio"] = s["audio"]
                    unknown[label]["fs"] = s["fs"]
                    unknown[label]["dur"] = s["end"] - s["start"]

        return segments, unknown

    def check_models_integrity(self, log_cb):
        log_cb("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –º–æ–¥–µ–ª–µ–π...")
        logger.info("Starting integrity check")
        
        # 1. Check CUDA
        cuda_ok = torch.cuda.is_available()
        log_cb(f"CUDA –¥–æ—Å—Ç—É–ø–Ω–∞: {'–î–∞' if cuda_ok else '–ù–µ—Ç'}")
        logger.info(f"CUDA available: {cuda_ok}")
        
        if not cuda_ok:
            log_cb("")
            log_cb("‚ö†Ô∏è CUDA –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:")
            log_cb("1. –ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω PyTorch —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π CUDA")
            log_cb("2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118")
            log_cb("3. –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–±–ª–∞—á–Ω—ã–π —Ä–µ–∂–∏–º (Deepgram)")
            logger.warning("CUDA not available - likely PyTorch CPU-only version")
        
        # 2. Check Whisper
        try:
            log_cb("–ó–∞–≥—Ä—É–∑–∫–∞ Whisper (—Ç–µ—Å—Ç)...")
            self._load_whisper()
            log_cb("Whisper –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ.")
            logger.info("Whisper loaded successfully")
        except Exception as e:
            log_cb(f"–û—à–∏–±–∫–∞ Whisper: {e}")
            logger.error(f"Whisper error: {e}", exc_info=True)

        # 3. Check Pyannote
        try:
            log_cb("–ó–∞–≥—Ä—É–∑–∫–∞ Pyannote (—Ç–µ—Å—Ç)...")
            self._load_pipeline()
            log_cb("Pyannote –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ.")
            logger.info("Pyannote loaded successfully")
        except Exception as e:
            log_cb(f"–û—à–∏–±–∫–∞ Pyannote: {e}")
            logger.error(f"Pyannote error: {e}", exc_info=True)
            
        log_cb("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
        logger.info("Integrity check completed")


# --- GOOGLE DRIVE ---

class GDriveClient:
    def __init__(self, log_cb=print):
        self.log_cb = log_cb
        self.ok = GDRIVE_AVAILABLE
        self.creds = None
        self.svc = None
        self.folder_id = None

    def log(self, msg: str):
        self.log_cb(f"[Google Drive] {msg}")

    def auth(self) -> bool:
        if not self.ok:
            return False

        scopes = ["https://www.googleapis.com/auth/drive.file"]

        if os.path.exists("token.json"):
            try:
                self.creds = Credentials.from_authorized_user_file(
                    "token.json", scopes
                )
            except Exception:
                os.remove("token.json")
                self.creds = None

        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired:
                try:
                    self.creds.refresh(Request())
                except Exception:
                    self.creds = None

            if not self.creds and os.path.exists("credentials.json"):
                try:
                    flow = InstalledAppFlow.from_client_secrets_file(
                        "credentials.json", scopes
                    )
                    self.creds = flow.run_local_server(port=0)
                except Exception:
                    return False

            if self.creds:
                with open("token.json", "w") as token:
                    token.write(self.creds.to_json())

        if not self.creds:
            return False

        try:
            self.svc = build("drive", "v3", credentials=self.creds)
            resp = (
                self.svc.files()
                .list(
                    q=f"name='{GDRIVE_FOLDER}' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                    spaces="drive",
                )
                .execute()
            )
            files = resp.get("files", [])
            if files:
                self.folder_id = files[0]["id"]
            else:
                meta = {
                    "name": GDRIVE_FOLDER,
                    "mimeType": "application/vnd.google-apps.folder",
                }
                folder = (
                    self.svc.files()
                    .create(body=meta, fields="id")
                    .execute()
                )
                self.folder_id = folder["id"]
            return True
        except Exception:
            return False

    def upload(self, path: str):
        if not os.path.exists(path):
            self.log(f"–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞—é –∑–∞–≥—Ä—É–∑–∫—É: {path}")
            return

        if not self.auth():
            self.log("–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Google Drive.")
            return

        try:
            file_metadata = {
                "name": os.path.basename(path),
                "parents": [self.folder_id],
            }
            media = MediaFileUpload(path, resumable=True)
            self.svc.files().create(
                body=file_metadata, media_body=media
            ).execute()
            self.log(f"–ó–∞–≥—Ä—É–∂–µ–Ω —Ñ–∞–π–ª: {os.path.basename(path)}")
        except Exception as e:
            self.log(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")


# --- –ì–ï–ù–ï–†–ê–¶–ò–Ø DOCX –ò–ó MARKDOWN-–ü–û–î–û–ë–ù–û–ì–û –¢–ï–ö–°–¢–ê ---

class DocxGenerator:
    @staticmethod
    def create_report(markdown_text: str, filename: str):
        if not DOCX_AVAILABLE:
            # —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äì –ø—Ä–æ—Å—Ç–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å .md/.txt
            alt = filename.replace(".docx", ".md")
            with open(alt, "w", encoding="utf-8") as f:
                f.write(markdown_text)
            return

        doc = Document()
        style = doc.styles["Normal"]
        style.font.name = "Calibri"
        style.font.size = Pt(11)

        lines = markdown_text.splitlines()
        table_data = []
        in_table = False

        for line in lines:
            if line.startswith("|") and line.endswith("|"):
                cols = [c.strip() for c in line.strip("|").split("|")]
                table_data.append(cols)
                in_table = True
                continue
            else:
                if in_table:
                    DocxGenerator._render_table(doc, table_data)
                    table_data = []
                    in_table = False

            if line.startswith("# "):
                doc.add_heading(line[2:], level=0)
            elif line.startswith("## "):
                doc.add_heading(line[3:], level=1)
            elif line.startswith("* "):
                p = doc.add_paragraph(style="List Bullet")
                DocxGenerator._render_runs(p, line[2:])
            else:
                p = doc.add_paragraph()
                DocxGenerator._render_runs(p, line)

        if in_table:
            DocxGenerator._render_table(doc, table_data)

        doc.save(filename)

    @staticmethod
    def _render_table(doc, table_data):
        if not table_data:
            return
        rows = len(table_data)
        cols = len(table_data[0])
        table = doc.add_table(rows=rows, cols=cols)
        table.style = "Table Grid"

        for r, row in enumerate(table_data):
            for c, val in enumerate(row):
                cell = table.rows[r].cells[c]
                cell.text = val
                if r == 0:
                    for run in cell.paragraphs[0].runs:
                        run.bold = True

    @staticmethod
    def _render_runs(paragraph, text: str):
        # –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–µ—Ä **–∂–∏—Ä–Ω–æ–≥–æ** —Ç–µ–∫—Å—Ç–∞
        parts = re.split(r"(\*\*.*?\*\*)", text)
        for part in parts:
            if not part:
                continue
            if part.startswith("**") and part.endswith("**"):
                run = paragraph.add_run(part[2:-2])
                run.bold = True
            else:
                paragraph.add_run(part)


# --- LLM-–ö–õ–ò–ï–ù–¢ ---

class LLMClient:
    def __init__(self):
        pass

    def _estimate_tokens(self, text: str) -> int:
        """–û—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ (–≥—Ä—É–±–∞—è: ~3.5 —Å–∏–º–≤–æ–ª–∞ –Ω–∞ —Ç–æ–∫–µ–Ω)"""
        return int(len(text) / 3.5)
    
    def _split_transcript_by_time(self, text: str) -> list:
        """–†–∞–∑–±–∏–≤–∞–µ—Ç —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—É –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ –º–∏–Ω—É—Ç–∞–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞"""
        chunks = []
        current_chunk = []
        
        minutes = config.get("chunk_minutes", 55)
        if not minutes or minutes <= 0:
            minutes = 55
        
        seconds_limit = minutes * 60
        current_threshold = seconds_limit
        
        lines = text.splitlines()
        
        for line in lines:
            match = re.match(r"^\[(\d+(?:\.\d+)?)\]", line.strip())
            if match:
                timestamp = float(match.group(1))
                if timestamp > current_threshold:
                    if current_chunk:
                        chunks.append("\n".join(current_chunk))
                        current_chunk = []
                    while timestamp > current_threshold:
                        current_threshold += seconds_limit
            
            current_chunk.append(line)
        
        if current_chunk:
            chunks.append("\n".join(current_chunk))
            
        if not chunks:
            return [text]
            
        return chunks

    def summarize(self, transcript_text: str, progress_cb=None, stop_event=None) -> str:
        """
        –£–º–Ω–∞—è —Å—É–º–º–∞—Ä–∏–∑–∞—Ü–∏—è —Å –≥–∏–±–∫–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–æ–π —É—Å–ª–æ–≤–∏–π —Ä–∞–∑–±–∏–µ–Ω–∏—è.
        """
        current_system_prompt = config.get("system_prompt") or ""
        current_system_prompt = current_system_prompt.replace(
            "{date}", datetime.now().strftime("%d.%m.%Y")
        )

        token_limit = config.get("llm_token_limit", 12000)
        use_token_check = config.get("enable_token_limit", True)
        force_split = config.get("force_time_split", False)

        full_text_tokens = self._estimate_tokens(transcript_text)
        should_split = force_split or (use_token_check and full_text_tokens > token_limit)
        
        # –í–ï–¢–ö–ê 1: –û–î–ò–ù –ü–†–û–•–û–î
        if not should_split:
            if progress_cb:
                msg = f"–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç ({full_text_tokens} —Ç–æ–∫–µ–Ω–æ–≤). –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º..."
                if full_text_tokens > token_limit: msg += " (–õ–∏–º–∏—Ç –ø—Ä–µ–≤—ã—à–µ–Ω)"
                progress_cb(msg)
            return self._call_llm_stream(current_system_prompt, transcript_text, progress_cb, stop_event)
        
        # –í–ï–¢–ö–ê 2: –ò–¢–ï–†–ê–¢–ò–í–ù–´–ô –†–ï–ñ–ò–ú
        chunks = self._split_transcript_by_time(transcript_text)
        total_chunks = len(chunks)
        
        if total_chunks <= 1:
            return self._call_llm_stream(current_system_prompt, transcript_text, progress_cb, stop_event)

        if progress_cb:
            chunk_min = config.get('chunk_minutes', 55)
            reason = "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ" if force_split else "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Ç–æ–∫–µ–Ω–æ–≤"
            progress_cb(f"–†–µ–∂–∏–º: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π ({reason}). –†–∞–∑–±–∏—Ç–æ –Ω–∞ {total_chunks} —á–∞—Å—Ç–µ–π.")

        intermediate_results = []
        
        for i, chunk in enumerate(chunks):
            # –ü–†–û–í–ï–†–ö–ê –û–¢–ú–ï–ù–´
            if stop_event and stop_event.is_set(): raise OperationCancelled()
            
            part_num = i + 1
            if progress_cb:
                progress_cb(f"–ê–Ω–∞–ª–∏–∑ —á–∞—Å—Ç–∏ {part_num}/{total_chunks}...")
            
            chunk_system_prompt = (
                f"–¢—ã –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—à—å –ß–ê–°–¢–¨ {part_num} –∏–∑ {total_chunks}.\n"
                f"–¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –∏–∑–≤–ª–µ—á—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —ç—Ç–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞, –°–¢–†–û–ì–û —Å–ª–µ–¥—É—è —Ä–æ–ª–∏ –Ω–∏–∂–µ.\n"
                f"=== –¢–í–û–Ø –†–û–õ–¨ ===\n{current_system_prompt}\n"
            )
            
            part_response = self._call_llm(chunk_system_prompt, chunk, stream=False)
            intermediate_results.append(f"--- –û–¢–ß–ï–¢ –ü–û –ß–ê–°–¢–ò {part_num} ---\n{part_response}\n")
        
        if progress_cb:
            progress_cb("–ö–æ–Ω—Å–æ–ª–∏–¥–∞—Ü–∏—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞...")
            
        combined_text = "\n".join(intermediate_results)
        final_user_message = (
            "–ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç—á–µ—Ç—ã. –û–±—ä–µ–¥–∏–Ω–∏ –∏—Ö –≤ –æ–¥–∏–Ω —Å–≤—è–∑–Ω—ã–π —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç.\n\n"
            f"–ú–ê–¢–ï–†–ò–ê–õ–´:\n{combined_text}"
        )
        
        return self._call_llm_stream(current_system_prompt, final_user_message, progress_cb, stop_event)


    def _prepare_request_data(self, system_prompt, user_text, stream=True):
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_text},
        ]
        
        provider = config.get("llm_provider")
        
        if provider == "openrouter":
            url = "https://openrouter.ai/api/v1/chat/completions"
            headers = {
                "Authorization": f"Bearer {config.get('or_key')}",
                "Content-Type": "application/json",
                "HTTP-Referer": "https://github.com/DarthSilent/NeuralSecretary",
            }
            data = {
                "model": config.get("or_model"),
                "messages": messages,
                "stream": stream,
            }
            if not stream:
                data["max_tokens"] = 2500 
                
        else:
            url = config.get("local_url")
            headers = {"Content-Type": "application/json"}
            ctx = config.get("llm_token_limit", 12000)
            data = {
                "model": config.get("local_model"),
                "messages": messages,
                "stream": stream,
                "options": {
                    "num_ctx": ctx
                }
            }
            
        return url, headers, data

    def _call_llm(self, system_prompt, user_text, stream=False) -> str:
    
        url, headers, data = self._prepare_request_data(system_prompt, user_text, stream=False)
        try:
            resp = requests.post(url, headers=headers, json=data)
            if resp.status_code != 200:
                return f"Error {resp.status_code}: {resp.text}"
            
            result = resp.json()
            if "choices" in result and len(result["choices"]) > 0:
                return result["choices"][0].get("message", {}).get("content", "")
            return ""
        except Exception as e:
            return f"Error: {e}"

    def _call_llm_stream(self, system_prompt, user_text, progress_cb, stop_event=None) -> str:
        url, headers, data = self._prepare_request_data(system_prompt, user_text, stream=True)
        try:
            resp = requests.post(url, headers=headers, json=data, stream=True)
            if resp.status_code != 200:
                try:
                    err_msg = resp.json().get('error', {}).get('message', resp.text)
                except:
                    err_msg = resp.text
                return f"–û—à–∏–±–∫–∞ LLM: {resp.status_code} {err_msg}"

            collected_text = []
            for line in resp.iter_lines():
                # –ü–†–û–í–ï–†–ö–ê –û–¢–ú–ï–ù–´ –í–û –í–†–ï–ú–Ø –°–¢–†–ò–ú–ò–ù–ì–ê
                if stop_event and stop_event.is_set():
                    raise OperationCancelled()

                if line:
                    decoded_line = line.decode('utf-8').strip()
                    if decoded_line.startswith("data: "):
                        json_str = decoded_line[6:]
                        if json_str == "[DONE]":
                            break
                        try:
                            chunk = json.loads(json_str)
                            if "choices" in chunk and len(chunk["choices"]) > 0:
                                delta = chunk["choices"][0].get("delta", {})
                                content = delta.get("content", "")
                                if content:
                                    collected_text.append(content)
                                    if progress_cb:
                                        progress_cb(content)
                        except json.JSONDecodeError:
                            pass
            return "".join(collected_text)

        except OperationCancelled:
            raise # –ü—Ä–æ–∫–∏–¥—ã–≤–∞–µ–º –Ω–∞–≤–µ—Ä—Ö
        except Exception as e:
            return f"–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å LLM: {e}"

# --- OLLAMA ---

class OllamaManager:
    @staticmethod
    def is_installed() -> bool:
        try:
            r = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            return r.returncode == 0
        except Exception:
            return False

    @staticmethod
    def get_local_models():
        if not OllamaManager.is_installed():
            return []
        r = subprocess.run(
            ["ollama", "list"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        lines = [l.strip() for l in r.stdout.splitlines() if l.strip()]
        models = []
        for line in lines[1:]:
            parts = line.split()
            if parts:
                models.append(parts[0])
        return models

    @staticmethod
    def pull_model(model_id: str, progress_cb, done_cb):
        """
        –ó–∞–ø—É—Å–∫–∞–µ–º `ollama pull model_id` –∏ –ø–∞—Ä—Å–∏–º –ø—Ä–æ—Ü–µ–Ω—Ç—ã –∏–∑ stdout.
        progress_cb(progress: float, message: str)
        done_cb(success: bool, model_id: str)
        """
        try:
            proc = subprocess.Popen(
                ["ollama", "pull", model_id],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
            )
        except Exception as e:
            done_cb(False, model_id)
            return

        for line in proc.stdout:
            m = re.search(r"(\d+)%", line)
            if m:
                pct = int(m.group(1))
                progress_cb(pct / 100.0, f"–ó–∞–≥—Ä—É–∑–∫–∞ {model_id}: {pct}%")

        proc.wait()
        done_cb(proc.returncode == 0, model_id)


class OllamaModelShop(ctk.CTkToplevel):
    def __init__(self, parent, model_var: ctk.StringVar):
        super().__init__(parent)
        self.title("–ú–∞–≥–∞–∑–∏–Ω –º–æ–¥–µ–ª–µ–π Ollama")
        self.geometry("520x480")
        self.attributes("-topmost", True)  # Always on top
        self.model_var = model_var
        
        # Get list of installed models once
        self.installed_models = set(OllamaManager.get_local_models() or [])

        self.progress = ctk.CTkProgressBar(self, mode="determinate")
        self.progress.pack(fill="x", padx=10, pady=(10, 0))
        self.progress.set(0.0)

        self.status_label = ctk.CTkLabel(self, text="")
        self.status_label.pack(padx=10, pady=(0, 10))

        self._build_ui()

    def _build_ui(self):
        tabs = ctk.CTkTabview(self)
        tabs.pack(fill="both", expand=True, padx=10, pady=10)

        for group_name, models in OLLAMA_MODELS.items():
            frame = tabs.add(group_name)
            for m in models:
                model_id = m["id"]
                is_installed = model_id in self.installed_models
                
                row = ctk.CTkFrame(frame)
                row.pack(fill="x", padx=5, pady=5)
                
                # Model name label with optional installed indicator
                name_text = f"‚úì {m['name']}" if is_installed else m["name"]
                label_color = ("#2ecc71", "#27ae60") if is_installed else ("gray10", "gray90")
                ctk.CTkLabel(
                    row, 
                    text=name_text,
                    text_color=label_color
                ).pack(side="left", padx=5)
                
                # Select button (disabled if not installed)
                select_btn = ctk.CTkButton(
                    row,
                    text="–í—ã–±—Ä–∞—Ç—å",
                    command=lambda mid=model_id: self._select_model(mid),
                    state="normal" if is_installed else "disabled"
                )
                select_btn.pack(side="right", padx=5)
                
                # Download button (changes to Re-download if installed)
                download_text = "–û–±–Ω–æ–≤–∏—Ç—å" if is_installed else "–°–∫–∞—á–∞—Ç—å"
                ctk.CTkButton(
                    row,
                    text=download_text,
                    command=lambda mid=model_id: self._pull_model(mid),
                ).pack(side="right", padx=5)

    def log(self, text: str):
        self.status_label.configure(text=text)

    def _select_model(self, model_id: str):
        self.model_var.set(model_id)
        self.status_label.configure(text=f"–í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {model_id}")

    def _pull_model(self, model_id: str):
        if not OllamaManager.is_installed():
            messagebox.showerror(
                "Ollama",
                "Ollama –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ PATH.",
            )
            return

        self.progress.set(0.0)
        self.status_label.configure(text=f"–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ {model_id}...")
        thread = threading.Thread(
            target=self._pull_thread, args=(model_id,), daemon=True
        )
        thread.start()

    def _pull_thread(self, model_id: str):
        def on_progress(frac, msg):
            self.after(
                0,
                lambda: (self.progress.set(frac), self.status_label.configure(text=msg)),
            )

        def on_done(success, mid):
            def ui():
                if success:
                    self.progress.set(1.0)
                    self.status_label.configure(
                        text=f"–ú–æ–¥–µ–ª—å {mid} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞."
                    )
                    # –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
                    models = OllamaManager.get_local_models() or ["None"]
                    if mid in models:
                        self.model_var.set(mid)
                    # Refresh installed models list and rebuild UI
                    self.installed_models = set(models)
                    self._rebuild_ui()
                else:
                    self.status_label.configure(
                        text=f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ {mid}."
                    )

            self.after(0, ui)

        OllamaManager.pull_model(model_id, on_progress, on_done)
    
    def _rebuild_ui(self):
        """Rebuild the UI after downloading a model to update installed indicators"""
        # Find and destroy the tabs widget
        for widget in self.winfo_children():
            if isinstance(widget, ctk.CTkTabview):
                widget.destroy()
                break
        
        # Rebuild tabs with updated installed models
        self._build_ui()




# --- –ú–ê–°–¢–ï–† –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –ù–ï–ò–ó–í–ï–°–¢–ù–´–• –°–ü–ò–ö–ï–†–û–í ---

class IdentifyWizard(ctk.CTkToplevel):
    def __init__(self, parent, unknown_map: dict, voice_db: dict):
        super().__init__(parent)
        self.title("–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–ø–∏–∫–µ—Ä–æ–≤")
        self.geometry("420x320")
        self.unknown = unknown_map
        self.voice_db = voice_db
        self.result_names = {}
        self.save_flags = {}
        self.keys = list(unknown_map.keys())
        self.index = 0
        
        # Collect all available names: from DB + any new ones assigned in this session
        self.available_names = sorted(list(voice_db.keys()))

        self._build_ui()

    def _build_ui(self):
        self.lift()
        self.focus_force()
        self.grab_set()

        self.label = ctk.CTkLabel(self, text="–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–ø–∏–∫–µ—Ä")
        self.label.pack(pady=15)

        ctk.CTkButton(
            self,
            text="‚ñ∂Ô∏è –ü—Ä–æ—Å–ª—É—à–∞—Ç—å –ø—Ä–∏–º–µ—Ä",
            command=self._play_sample,
        ).pack(pady=5)

        ctk.CTkLabel(self, text="–ò–º—è —Å–ø–∏–∫–µ—Ä–∞:").pack(pady=(15, 5))
        
        # Use ComboBox instead of Entry
        self.name_combo = ctk.CTkComboBox(self, values=self.available_names)
        self.name_combo.set("")
        self.name_combo.pack(pady=5)

        self.save_var = ctk.BooleanVar(value=True)
        ctk.CTkCheckBox(
            self, text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –±–∞–∑—É –≥–æ–ª–æ—Å–æ–≤", variable=self.save_var
        ).pack(pady=5)

        ctk.CTkButton(self, text="–î–∞–ª–µ–µ", command=self._next).pack(
            pady=15
        )

        self._update_ui()

    def _update_ui(self):
        if self.index >= len(self.keys):
            self.destroy()
            return
        spk_id = self.keys[self.index]
        self.label.configure(text=f"–§—Ä–∞–≥–º–µ–Ω—Ç —Å–ø–∏–∫–µ—Ä–∞: {spk_id}")
        self.name_combo.set("")
        self.save_var.set(True)
        
        # Update available names in case user added a new one in previous step
        current_session_names = sorted(list(set(self.result_names.values())))
        all_names = sorted(list(set(list(self.voice_db.keys()) + current_session_names)))
        self.name_combo.configure(values=all_names)

    def _play_sample(self):
        if self.index >= len(self.keys):
            return
        spk_id = self.keys[self.index]
        sample = self.unknown[spk_id]
        try:
            data, sr = sf.read(sample["audio"])
            sd.play(data, sample["fs"])
        except Exception:
            pass

    def _next(self):
        if self.index < len(self.keys):
            name = self.name_combo.get().strip()
            spk_id = self.keys[self.index]
            if name:
                self.result_names[spk_id] = name
                self.save_flags[spk_id] = self.save_var.get()
                
                # Auto-save sample to speaker folder
                import shutil
                import glob
                from pydub import AudioSegment
                
                speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
                os.makedirs(speaker_dir, exist_ok=True)
                
                # Find next sample number
                existing_samples = glob.glob(os.path.join(speaker_dir, "sample_*.wav"))
                next_num = len(existing_samples) + 1
                sample_path = os.path.join(speaker_dir, f"sample_{next_num:03d}.wav")
                
                # Convert audio to WAV format if needed
                ch = self.unknown[spk_id]
                source_file = ch["audio"]
                
                # Check if already WAV
                if source_file.lower().endswith('.wav'):
                    shutil.copy(source_file, sample_path)
                else:
                    # Convert to WAV using pydub
                    try:
                        audio = AudioSegment.from_file(source_file)
                        audio.export(sample_path, format="wav")
                        logger.info(f"Converted {os.path.basename(source_file)} to WAV")
                    except Exception as e:
                        logger.warning(f"Failed to convert {source_file}: {e}. Copying as-is.")
                        shutil.copy(source_file, sample_path)
                
                logger.info(f"Saved sample for {name}: {sample_path}")
                
                # Update or create speaker in voice_db with initial status
                if name not in self.voice_db:
                    self.voice_db[name] = {
                        "embedding": None,
                        "trained": False,
                        "sample_count": next_num
                    }
                else:
                    # Update sample count for existing speaker
                    if isinstance(self.voice_db[name], dict):
                        self.voice_db[name]["sample_count"] = next_num
        self.index += 1
        self._update_ui()


# --- –î–û–ë–ê–í–õ–ï–ù–ò–ï –°–ü–ò–ö–ï–†–ê ---

class AddSpeakerDialog(ctk.CTkToplevel):
    def __init__(self, master, voice_db, recorder, ai, log_cb, on_done, existing_name=None):
        super().__init__(master)
        self.title("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥–æ–ª–æ—Å–∞" if not existing_name else f"–î–æ–æ–±—É—á–µ–Ω–∏–µ: {existing_name}")
        self.geometry("500x650")
        self.voice_db = voice_db
        self.recorder = recorder
        self.ai = ai
        self.log_cb = log_cb
        self.on_done = on_done
        self.existing_name = existing_name

        self._build_ui()

    def _build_ui(self):
        self.lift()
        self.focus_force()
        self.grab_set()

        ctk.CTkLabel(self, text="–ò–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞:", font=("Segoe UI", 14, "bold")).pack(pady=(20, 5))
        self.name_entry = ctk.CTkEntry(self, width=300)
        self.name_entry.pack(pady=5)
        
        # If re-training existing speaker, pre-fill and disable name field
        if self.existing_name:
            self.name_entry.insert(0, self.existing_name)
            self.name_entry.configure(state="disabled")

        # Instruction text box (resizable)
        instruction_frame = ctk.CTkFrame(self, fg_color="transparent")
        instruction_frame.pack(pady=10, padx=20, fill="both", expand=True)
        
        instruction_text = (
            "–î–ª—è –æ–±—É—á–µ–Ω–∏—è –≥–æ–ª–æ—Å–∞ –ø—Ä–æ–∏–∑–Ω–µ—Å–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∏–∂–µ:\n\n"
            f"{ENROLL_TEXT.replace('{name}', '[–∏–º—è]')}"
        ) if not self.existing_name else (
            "–ó–∞–ø–∏—à–∏—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–µ–º–ø–ª –≥–æ–ª–æ—Å–∞:\n\n"
            f"{RETRAIN_TEXT}"
        )
        
        self.instruction_box = ctk.CTkTextbox(
            instruction_frame,
            font=("Segoe UI", 12),
            wrap="word",
            height=150
        )
        self.instruction_box.pack(fill="both", expand=True)
        self.instruction_box.insert("0.0", instruction_text)
        self.instruction_box.configure(state="disabled")

        ctk.CTkLabel(self, text="–ó–∞–ø–∏—Å—å —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞:", font=("Segoe UI", 12, "bold")).pack(pady=(15, 5))
        ctk.CTkButton(
            self,
            text="üé§ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å",
            command=self._start_rec,
            height=35
        ).pack(pady=5)
        self.stop_btn = ctk.CTkButton(
            self,
            text="‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å",
            fg_color="red",
            state="disabled",
            command=self._stop_rec,
            height=35
        )
        self.stop_btn.pack(pady=5)

        ctk.CTkLabel(self, text="–ò–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≥–æ—Ç–æ–≤—ã–π —Ñ–∞–π–ª:", font=("Segoe UI", 12, "bold")).pack(
            pady=(15, 5)
        )
        ctk.CTkButton(
            self, 
            text="üìÇ –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª...", 
            command=self._upload_file,
            height=35
        ).pack(pady=5)

        self.timer_label = ctk.CTkLabel(self, text="00:00", font=("Segoe UI", 20, "bold"))
        self.timer_label.pack(pady=5)

        self.progress = ctk.CTkProgressBar(self, mode="indeterminate")
        # pack only when processing
        
        self.status_label = ctk.CTkLabel(self, text="", text_color="gray")
        self.status_label.pack(pady=5)

        self.rec_start_time = 0
        self.is_recording = False

    def _start_rec(self):
        filename = f"enroll_{uuid.uuid4().hex}.wav"
        self.recorder.start(filename)
        self.stop_btn.configure(state="normal")
        self.is_recording = True
        self.rec_start_time = time.time()
        self._update_timer()

    def _update_timer(self):
        if self.is_recording:
            elapsed = int(time.time() - self.rec_start_time)
            self.timer_label.configure(text=f"{elapsed // 60:02}:{elapsed % 60:02}")
            self.after(100, self._update_timer)

    def _stop_rec(self):
        self.is_recording = False
        ok = self.recorder.stop(force_wav=True)
        self.stop_btn.configure(state="disabled")
        if ok:
            self._start_processing(self.recorder.final_target)

    def _upload_file(self):
        path = filedialog.askopenfilename()
        if path:
            self._start_processing(path)

    def _start_processing(self, path):
        name = self.name_entry.get().strip()
        if not name:
            messagebox.showwarning("–ò–º—è", "–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏ –∏–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞.")
            return

        self.progress.pack(pady=10)
        self.progress.start()
        self.status_label.configure(text="–ò–¥—ë—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞... (–ú–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 10-20 —Å–µ–∫)")
        
        threading.Thread(
            target=self._process_sample_thread,
            args=(path, name),
            daemon=True
        ).start()

    def _process_sample_thread(self, path, name):
        try:
            import glob
            from pydub import AudioSegment
            
            # Create speaker-specific directory
            speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
            os.makedirs(speaker_dir, exist_ok=True)
            
            # Find next sample number
            existing_samples = glob.glob(os.path.join(speaker_dir, "sample_*.wav"))
            next_num = len(existing_samples) + 1
            sample_path = os.path.join(speaker_dir, f"sample_{next_num:03d}.wav")
            
            self.log_cb(f"–û–±—É—á–µ–Ω–∏–µ –≥–æ–ª–æ—Å–∞: {name}")
            
            # Convert to WAV and save
            AudioSegment.from_file(path).export(sample_path, format="wav")
            
            # Create embedding
            emb = self.ai.create_embedding(sample_path)
            
            # Update voice_db with new format
            self.voice_db[name] = {
                "embedding": emb,
                "trained": True,
                "sample_count": next_num
            }
            
            self.after(0, self.on_done)
            self.after(0, lambda: messagebox.showinfo("–£—Å–ø–µ—Ö", "–ì–æ–ª–æ—Å —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!"))
            self.after(0, self.destroy)
        except Exception as e:
            self.log_cb(f"–û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è: {e}")
            self.after(0, lambda: self.progress.stop())
            self.after(0, lambda: self.progress.pack_forget())
            self.after(0, lambda: self.status_label.configure(text=f"–û—à–∏–±–∫–∞: {e}"))
class MicTesterWindow(ctk.CTkToplevel):
    def __init__(self, parent, device_name):
        super().__init__(parent)
        self.title("–¢–µ—Å—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞")
        self.geometry("400x150")
        self.device_name = device_name
        self.stream = None
        self.running = True
        
        # UI
        ctk.CTkLabel(self, text=f"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {device_name}", font=("Segoe UI", 12, "bold")).pack(pady=(15, 5))
        
        self.progress = ctk.CTkProgressBar(self, width=300, height=20, mode="determinate")
        self.progress.pack(pady=10)
        self.progress.set(0.0)
        
        self.lbl_status = ctk.CTkLabel(self, text="–°–ª—É—à–∞—é —Å–∏–≥–Ω–∞–ª...", text_color="gray")
        self.lbl_status.pack(pady=5)
        
        ctk.CTkButton(self, text="–ó–∞–∫—Ä—ã—Ç—å", command=self.destroy, fg_color="#e74c3c", hover_color="#c0392b").pack(pady=10)
        
        # –ó–∞–ø—É—Å–∫ –ø–æ—Ç–æ–∫–∞ —á—Ç–µ–Ω–∏—è
        self.thread = threading.Thread(target=self._listen_loop, daemon=True)
        self.thread.start()

    def _listen_loop(self):
        # –ü–∞—Ä—Å–∏–º ID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        dev_id = None
        if self.device_name and ":" in self.device_name:
            try:
                dev_id = int(self.device_name.split(":")[0])
            except ValueError:
                pass
        
        def callback(indata, frames, time, status):
            if not self.running:
                raise sd.CallbackStop()
            
            # –†–∞—Å—á–µ—Ç –≥—Ä–æ–º–∫–æ—Å—Ç–∏ (RMS)
            vol = np.linalg.norm(indata) / np.sqrt(len(indata))
            # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è UI (—É—Å–∏–ª–µ–Ω–∏–µ x5)
            vol_ui = min(vol * 5, 1.0)
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            try:
                if self.winfo_exists():
                    self.progress.set(vol_ui)
            except:
                pass

        try:
            with sd.InputStream(device=dev_id, channels=1, callback=callback, samplerate=16000):
                while self.running and self.winfo_exists():
                    sd.sleep(100)
        except Exception as e:
            if self.winfo_exists():
                self.lbl_status.configure(text=f"–û—à–∏–±–∫–∞: {e}")

    def destroy(self):
        self.running = False
        super().destroy()

# --- UI –ö–û–ú–ü–û–ù–ï–ù–¢–´ ---

class TranscriptSegment(ctk.CTkFrame):
    def __init__(self, parent, start_time: float, end_time: float, speaker: str, text: str, 
                 on_seek=None, voice_db=None):
        super().__init__(parent, fg_color=("gray85", "gray20"), corner_radius=8)
        self.start_time = start_time
        self.end_time = end_time
        self.on_seek = on_seek
        
        # Layout: [Time] [Speaker] [Text]
        self.grid_columnconfigure(2, weight=1)
        
        # 1. Time Button (Click-to-Seek)
        time_str = self._format_time(start_time)
        self.time_btn = ctk.CTkButton(
            self, 
            text=f"‚è± {time_str}", 
            width=80, 
            height=28,
            fg_color=("gray70", "gray30"),
            hover_color=("gray60", "gray40"),
            command=self._on_time_click
        )
        self.time_btn.grid(row=0, column=0, padx=5, pady=5, sticky="nw")
        
        # 2. Speaker Selector
        speakers = sorted(list(voice_db.keys())) if voice_db else []
        if speaker not in speakers:
            speakers.append(speaker)
            
        self.speaker_var = ctk.StringVar(value=speaker)
        self.speaker_menu = ctk.CTkOptionMenu(
            self,
            variable=self.speaker_var,
            values=speakers,
            width=140,
            height=28
        )
        self.speaker_menu.grid(row=0, column=1, padx=5, pady=5, sticky="nw")
        
        # 3. Text Editor
        # Use Textbox for multi-line support
        self.text_box = ctk.CTkTextbox(
            self, 
            height=60, 
            font=("Segoe UI", 12),
            wrap="word",
            activate_scrollbars=False
        )
        self.text_box.grid(row=0, column=2, padx=5, pady=5, sticky="ew")
        self.text_box.insert("0.0", text)
        
        # Auto-resize height based on text content (simple heuristic)
        lines = text.count('\n') + (len(text) // 80) + 1
        new_height = min(max(lines * 20, 40), 150)
        self.text_box.configure(height=new_height)

    def _format_time(self, seconds: float) -> str:
        m = int(seconds // 60)
        s = int(seconds % 60)
        return f"{m:02d}:{s:02d}"

    def _on_time_click(self):
        if self.on_seek:
            self.on_seek(self.start_time)

    def get_data(self):
        return {
            "start": self.start_time,
            "end": self.end_time,
            "label": self.speaker_var.get(),
            "text": self.text_box.get("0.0", "end").strip()
        }

# --- LINK FILES DIALOG ---

class LinkFilesDialog(ctk.CTkToplevel):
    """Dialog for manually linking audio and transcript files"""
    def __init__(self, parent, file_assoc, log_cb):
        super().__init__(parent)
        self.title("–ü—Ä–∏–≤—è–∑–∫–∞ —Ñ–∞–π–ª–æ–≤")
        self.geometry("600x250")
        self.file_assoc = file_assoc
        self.log_cb = log_cb
        
        self.audio_path = None
        self.transcript_path = None
        
        self._build_ui()
        self.lift()
        self.focus_force()
        self.grab_set()
    
    def _build_ui(self):
        # Audio file section
        ctk.CTkLabel(
            self, text="–ê—É–¥–∏–æ —Ñ–∞–π–ª:", font=("Segoe UI", 14, "bold")
        ).pack(pady=(20, 5))
        
        audio_frame = ctk.CTkFrame(self)
        audio_frame.pack(fill="x", padx=20, pady=5)
        
        self.audio_label = ctk.CTkLabel(
            audio_frame, text="–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω", text_color="gray"
        )
        self.audio_label.pack(side="left", padx=10)
        
        ctk.CTkButton(
            audio_frame, text="üìÅ –û–±–∑–æ—Ä", width=100,
            command=self._pick_audio
        ).pack(side="right", padx=10, pady=5)
        
        # Transcript file section
        ctk.CTkLabel(
            self, text="–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç:", font=("Segoe UI", 14, "bold")
        ).pack(pady=(15, 5))
        
        transcript_frame = ctk.CTkFrame(self)
        transcript_frame.pack(fill="x", padx=20, pady=5)
        
        self.transcript_label = ctk.CTkLabel(
            transcript_frame, text="–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω", text_color="gray"
        )
        self.transcript_label.pack(side="left", padx=10)
        
        ctk.CTkButton(
            transcript_frame, text="üìÅ –û–±–∑–æ—Ä", width=100,
            command=self._pick_transcript
        ).pack(side="right", padx=10, pady=5)
        
        # Buttons
        btn_frame = ctk.CTkFrame(self, fg_color="transparent")
        btn_frame.pack(pady=20)
        
        ctk.CTkButton(
            btn_frame, text="‚úÖ –°–≤—è–∑–∞—Ç—å", width=120,
            fg_color="green", hover_color="#006400",
            command=self._link_files
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            btn_frame, text="‚ùå –û—Ç–º–µ–Ω–∞", width=120,
            fg_color="gray", hover_color="darkgray",
            command=self.destroy
        ).pack(side="left", padx=10)
    
    def _pick_audio(self):
        path = filedialog.askopenfilename(
            title="–í—ã–±—Ä–∞—Ç—å –∞—É–¥–∏–æ —Ñ–∞–π–ª",
            filetypes=[
                ("Audio Files", "*.wav *.mp3 *.m4a *.flac"),
                ("All Files", "*.*")
            ]
        )
        if path:
            self.audio_path = path
            self.audio_label.configure(
                text=os.path.basename(path),
                text_color=("black", "white")
            )
    
    def _pick_transcript(self):
        path = filedialog.askopenfilename(
            title="–í—ã–±—Ä–∞—Ç—å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if path:
            self.transcript_path = path
            self.transcript_label.configure(
                text=os.path.basename(path),
                text_color=("black", "white")
            )
    
    def _link_files(self):
        if not self.audio_path or not self.transcript_path:
            messagebox.showwarning(
                "–í–Ω–∏–º–∞–Ω–∏–µ",
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–±–∞ —Ñ–∞–π–ª–∞"
            )
            return
        
        try:
            self.file_assoc.associate(self.audio_path, self.transcript_path)
            self.log_cb(f"‚úÖ –§–∞–π–ª—ã —Å–≤—è–∑–∞–Ω—ã: {os.path.basename(self.audio_path)} ‚Üî {os.path.basename(self.transcript_path)}")
            messagebox.showinfo("–£—Å–ø–µ—Ö", "–§–∞–π–ª—ã —É—Å–ø–µ—à–Ω–æ —Å–≤—è–∑–∞–Ω—ã!")
            self.destroy()
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≤—è–∑–∞—Ç—å —Ñ–∞–π–ª—ã:\n{e}")

# --- –û–°–ù–û–í–ù–û–ï –û–ö–ù–û –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ---

import pickle


class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(APP_TITLE)
        self.geometry("1200x800")
        self.stop_event = threading.Event()



        self.voice_db = (
            pickle.load(open(DB_FILE, "rb"))
            if os.path.exists(DB_FILE)
            else {}
        )
    
        # Migrate old voice_db format to new format
        self._migrate_voice_db()

        self.recorder = AudioRecorder()
        self.ai = AIProcessor()
        self.llm = LLMClient()
        self.gdrive = GDriveClient(self._log)
        self.file_assoc = FileAssociationManager()  # File association manager

        self.player = AudioPlayer()

        self.is_recording = False
        self.record_start_time = 0
        self.last_transcript_text = ""
        self.last_basename = ""
        self.current_audio_path = None  # Track current audio file for associations
        self.current_transcript_path = None  # Track current transcript file

        self._build_ui()

        if not config.get("hf_token"):
            self.after(
                1500,
                lambda: messagebox.showwarning(
                    "HF Token",
                    "–ù–µ –∑–∞–¥–∞–Ω HF Token. –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ –±—É–¥–µ—Ç.",
                ),
            )


    def _get_host_dirs(self, host_name: str):
        """
        Returns paths for (recordings_dir, transcripts_dir, reports_dir)
        based on the host name. Creates them if they don't exist.
        Structure:
          Meeting_Records/
            [Host Name]/
              –ó–∞–ø–∏—Å–∏/
              –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏/
              –û—Ç—á–µ—Ç—ã/
        """
        safe_host = sanitize_filename(host_name)
        base_dir = os.path.join(RECORDS_DIR, safe_host)
        
        rec_dir = os.path.join(base_dir, "–ó–∞–ø–∏—Å–∏")
        trans_dir = os.path.join(base_dir, "–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏")
        rep_dir = os.path.join(base_dir, "–û—Ç—á–µ—Ç—ã")
        
        os.makedirs(rec_dir, exist_ok=True)
        os.makedirs(trans_dir, exist_ok=True)
        os.makedirs(rep_dir, exist_ok=True)
        
        return rec_dir, trans_dir, rep_dir

    def _migrate_voice_db(self):
        """Migrate old voice_db format (name->embedding) to new format (name->dict)"""
        import glob
        
        migrated = False
        for name, data in list(self.voice_db.items()):
            if isinstance(data, np.ndarray):
                # Old format - convert to new format
                speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
                sample_count = len(glob.glob(os.path.join(speaker_dir, "sample_*.wav"))) if os.path.exists(speaker_dir) else 0
                
                self.voice_db[name] = {
                    "embedding": data,
                    "trained": True,
                    "sample_count": sample_count
                }
                migrated = True
                logger.info(f"Migrated {name} to new format (sample_count: {sample_count})")
            elif isinstance(data, dict):
                # New format - ensure all fields exist
                if "trained" not in data:
                    data["trained"] = data.get("embedding") is not None
                if "sample_count" not in data:
                    speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
                    data["sample_count"] = len(glob.glob(os.path.join(speaker_dir, "sample_*.wav"))) if os.path.exists(speaker_dir) else 0
        
        if migrated:
            self._save_db()
            logger.info("Voice DB migration completed")
    
    def _get_speaker_sample_count(self, name):
        """Get the number of samples for a speaker"""
        import glob
        speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
        if not os.path.exists(speaker_dir):
            return 0
        return len(glob.glob(os.path.join(speaker_dir, "sample_*.wav")))

    # --- —Å–ª—É–∂–µ–±–Ω—ã–µ –º–µ—Ç–æ–¥—ã ---

    def _save_db(self):
        pickle.dump(self.voice_db, open(DB_FILE, "wb"))

    def _log(self, msg: str):
        """Log message to status bar and log_box if it exists"""
        ts = datetime.now().strftime("%H:%M:%S")
        formatted_msg = f"[{ts}] {msg}"
        
        # Update status bar
        if hasattr(self, 'status_label'):
            self.status_label.configure(text=msg)
        
        # Also log to textbox if it exists (analysis page)
        if hasattr(self, 'log_box') and self.log_box.winfo_exists():
            try:
                self.log_box.insert("end", formatted_msg + "\n")
                self.log_box.see("end")
            except:
                pass

    def _toggle_log_box(self):
        if self.log_box_visible:
            self.log_box.grid_remove()
            self.log_toggle_btn.configure(text="‚ñ∂ –ü–æ–∫–∞–∑–∞—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –ª–æ–≥")
            self.log_box_visible = False
        else:
            self.log_box.grid(row=8, column=0, sticky="nsew", pady=5)
            self.log_toggle_btn.configure(text="‚ñº –°–∫—Ä—ã—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –ª–æ–≥")
            self.log_box_visible = True

    def _render_transcript(self, segments):
        """Render transcript segments as cards"""
        # Clear existing
        for widget in self.transcript_scroll.winfo_children():
            widget.destroy()
            
        if not segments:
            return

        for seg in segments:
            card = TranscriptSegment(
                self.transcript_scroll,
                start_time=seg["start"],
                end_time=seg["end"],
                speaker=seg["label"],
                text=seg["text"],
                on_seek=self._player_seek_to,
                voice_db=self.voice_db
            )
            card.pack(fill="x", pady=2, padx=2)

    def _player_seek_to(self, seconds):
        """Seek player to specific time"""
        if self.player:
            self.player.seek(seconds)
            # Update slider
            if hasattr(self, 'player_slider'):
                self.player_slider.set(seconds)
            # If paused, maybe play a bit? Or just update frame.
            # Let's just seek. User can press play.

    def _collect_transcript_from_ui(self) -> str:
        """Reconstruct transcript text from UI segments"""
        text_parts = []
        for widget in self.transcript_scroll.winfo_children():
            if isinstance(widget, TranscriptSegment):
                data = widget.get_data()
                # Format: [00:15] Speaker: Text
                time_str = widget._format_time(data["start"])
                text_parts.append(f"[{time_str}] {data['label']}: {data['text']}")
        return "\n".join(text_parts)

    def _save_transcript_changes(self):
        """Save edited transcript to file"""
        # Collect current transcript from UI
        transcript_text = self._collect_transcript_from_ui()
        
        if not transcript_text:
            self._log("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è")
            return
        
        # Determine save path
        if self.current_transcript_path and os.path.exists(self.current_transcript_path):
            # Save to existing file
            save_path = self.current_transcript_path
        else:
            # Ask user where to save
            save_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")],
                initialfile=f"{self.last_basename}.txt" if self.last_basename else "transcript.txt"
           )
            if not save_path:
                return
        
        try:
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(transcript_text)
            
            self.current_transcript_path = save_path
            self.last_transcript_text = transcript_text
            
            # Create association if we have audio
            if self.current_audio_path:
                self.file_assoc.associate(self.current_audio_path, save_path)
                self._log(f"‚úÖ –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∞—É–¥–∏–æ")
            else:
                self._log(f"‚úÖ –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {os.path.basename(save_path)}")
                
        except Exception as e:
            self._log(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª:\n{e}")
    
    def _show_link_files_dialog(self):
        """Show dialog to manually link audio and transcript files"""
        LinkFilesDialog(self, self.file_assoc, self._log)

    def _parse_and_render_transcript(self, text):
        """Parse transcript text and render as segments"""
        import re
        segments = []
        
        for idx, line in enumerate(text.strip().split('\n')):
            if not line.strip():
                continue
            
            # Try format: [time] Speaker: Text
            match = re.match(r'\[(\d+\.?\d*)\]\s*([^:]+):\s*(.+)', line)
            if match:
                try:
                    time_val = float(match.group(1))
                    speaker = match.group(2).strip()
                    txt = match.group(3).strip()
                    segments.append({
                        "start": time_val,
                        "end": time_val + 5.0,
                        "label": speaker,
                        "text": txt
                    })
                    continue
                except:
                    pass
            
            # Try format: Speaker: Text (no time)
            match2 = re.match(r'([^:]+):\s*(.+)', line)
            if match2:
                speaker = match2.group(1).strip()
                txt = match2.group(2).strip()
                segments.append({
                    "start": idx * 10.0,
                    "end": (idx + 1) * 10.0,
                    "label": speaker,
                    "text": txt
                })
        
        if segments:
            self._render_transcript(segments)
            self._log(f"‚úÖ –û—Ç–æ–±—Ä–∞–∂–µ–Ω–æ {len(segments)} —Å–µ–≥–º–µ–Ω—Ç–æ–≤")
    
    def _rename_speaker(self, old_name):
        """Rename a speaker in the voice database"""
        # Create dialog for new name
        dialog = ctk.CTkInputDialog(
            text=f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∏–º—è –¥–ª—è '{old_name}':",
            title="–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –≥–æ–ª–æ—Å–∞"
        )
        new_name = dialog.get_input()
        
        if not new_name or new_name.strip() == "":
            return
        
        new_name = new_name.strip()
        
        # Check if name already exists
        if new_name in self.voice_db and new_name != old_name:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ì–æ–ª–æ—Å —Å –∏–º–µ–Ω–µ–º '{new_name}' —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")
            return
        
        # Same name - nothing to do
        if new_name == old_name:
            return
        
        try:
            # Transfer data
            self.voice_db[new_name] = self.voice_db[old_name]
            del self.voice_db[old_name]
            
            # Rename samples directory if exists
            import glob
            old_dir = os.path.join(SAMPLES_DIR, sanitize_filename(old_name))
            new_dir = os.path.join(SAMPLES_DIR, sanitize_filename(new_name))
            
            if os.path.exists(old_dir):
                os.rename(old_dir, new_dir)
            
            # Save changes
            self._save_db()
            self._refresh_host_menu()
            self._log(f"‚úÖ –ì–æ–ª–æ—Å –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω: '{old_name}' ‚Üí '{new_name}'")
            
            # Refresh voices page
            if hasattr(self, 'current_page') and self.current_page == "voices":
                self._show_voices_page()
            
            messagebox.showinfo("–£—Å–ø–µ—Ö", f"–ì–æ–ª–æ—Å —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –Ω–∞ '{new_name}'!")
            
        except Exception as e:
            self._log(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è: {e}")
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –≥–æ–ª–æ—Å:\n{e}")

    # === –í–û–¢ –≠–¢–ò –ú–ï–¢–û–î–´ –ù–£–ñ–ù–û –í–°–¢–ê–í–ò–¢–¨ –° –û–¢–°–¢–£–ü–û–ú (4 –ü–†–û–ë–ï–õ–ê) ===

    def _cancel_processing(self):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ –û—Ç–º–µ–Ω–∞"""
        if messagebox.askyesno("–û—Ç–º–µ–Ω–∞", "–ü—Ä–µ—Ä–≤–∞—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é?"):
            self.stop_event.set()
            self._log("–ó–∞–ø—Ä–æ—Å –Ω–∞ –æ—Ç–º–µ–Ω—É –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω...")
            self.cancel_btn.configure(state="disabled", text="–û—Å—Ç–∞–Ω–æ–≤–∫–∞...")

    def _show_progress_ui(self, show=True):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç/—Å–∫—Ä—ã–≤–∞–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å –±–∞—Ä –∏ –∫–Ω–æ–ø–∫—É –æ—Ç–º–µ–Ω—ã"""
        if show:
            self.stop_event.clear() # –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º
            self.progress.pack(side="right", padx=10)
            self.progress.start()
            self.cancel_btn.configure(state="normal", text="‚ùå –û–¢–ú–ï–ù–ê")
            self.cancel_btn.pack(side="right", padx=5)
        else:
            self.progress.stop()
            self.progress.pack_forget()
            self.cancel_btn.pack_forget()

    def _enable_report_buttons(self):
        """–•–µ–ª–ø–µ—Ä –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –≤–∫–ª—é—á–µ–Ω–∏—è –∫–Ω–æ–ø–æ–∫ –æ—Ç—á–µ—Ç–∞"""
        if hasattr(self, "report_button_live") and self.report_button_live.winfo_exists():
            self.report_button_live.configure(state="normal")
        if hasattr(self, "report_button_file") and self.report_button_file.winfo_exists():
            self.report_button_file.configure(state="normal")
        if hasattr(self, "save_transcript_btn") and self.save_transcript_btn.winfo_exists():
            self.save_transcript_btn.configure(state="normal")

    # --- UI ---

    def _build_ui(self):
        """Build the main UI with sidebar navigation"""
        # Main layout: sidebar (left) + content (right)
        self.grid_columnconfigure(0, weight=0)  # Sidebar - fixed width
        self.grid_columnconfigure(1, weight=1)  # Content - expandable
        self.grid_rowconfigure(0, weight=1)
        
        # === SIDEBAR ===
        self.sidebar = ctk.CTkFrame(self, width=180, corner_radius=0, fg_color=("#dbdbdb", "#2b2b2b"))
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        self.sidebar.grid_propagate(False)
        
        # App title in sidebar
        ctk.CTkLabel(
            self.sidebar, 
            text="Meeting App", 
            font=("Segoe UI", 16, "bold")
        ).pack(pady=20)
        
        # Navigation buttons
        self.nav_buttons = {}
        nav_items = [
            ("üé§ –ó–∞–ø–∏—Å—å", self._show_recording_page),
            ("üìä –ê–Ω–∞–ª–∏–∑", self._show_analysis_page),
            ("üó£Ô∏è –ì–æ–ª–æ—Å–∞", self._show_voices_page),
            ("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", self._show_settings_page),
            ("üìÅ –§–∞–π–ª—ã", self._show_files_page),
        ]
        
        for text, command in nav_items:
            btn = ctk.CTkButton(
                self.sidebar,
                text=text,
                command=command,
                width=160,
                height=40,
                anchor="w",
                fg_color="transparent",
                text_color=("gray10", "gray90"),
                hover_color=("gray70", "gray30")
            )
            btn.pack(pady=5, padx=10)
            self.nav_buttons[text] = btn
        
        # === CONTENT AREA ===
        self.content_frame = ctk.CTkFrame(self, corner_radius=0)
        self.content_frame.grid(row=0, column=1, sticky="nsew", padx=0, pady=0)
        self.content_frame.grid_columnconfigure(0, weight=1)
        self.content_frame.grid_rowconfigure(0, weight=1)
        
        # === STATUS BAR (bottom) ===
        self.status_bar = ctk.CTkFrame(self, height=30, corner_radius=0)
        self.status_bar.grid(row=1, column=0, columnspan=2, sticky="ew")
        
        self.status_label = ctk.CTkLabel(self.status_bar, text="–ì–æ—Ç–æ–≤", anchor="w")
        self.status_label.pack(side="left", padx=10)
        
        # –ö–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã (—Å–ø—Ä–∞–≤–∞)
        self.cancel_btn = ctk.CTkButton(
            self.status_bar, 
            text="‚ùå –û–¢–ú–ï–ù–ê", 
            fg_color="#c0392b", 
            hover_color="#e74c3c",
            width=100,
            command=self._cancel_processing
        )
        # –ù–µ –¥–µ–ª–∞–µ–º pack —Å—Ä–∞–∑—É, –±—É–¥–µ–º –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ
        
        self.progress = ctk.CTkProgressBar(self.status_bar, mode="indeterminate", width=200)
        
        self._show_recording_page()
    
    def _clear_content(self):
        """Clear all widgets from content frame"""
        for widget in self.content_frame.winfo_children():
            widget.destroy()
    
    def _highlight_nav_button(self, button_text):
        """Highlight the active navigation button"""
        for text, btn in self.nav_buttons.items():
            if text == button_text:
                btn.configure(fg_color=("#3b8ed0", "#1f6aa5"))
            else:
                btn.configure(fg_color="transparent")
    
    # === PAGE METHODS ===
    
    def _show_recording_page(self):
        """Show the recording page"""
        self._clear_content()
        self._highlight_nav_button("üé§ –ó–∞–ø–∏—Å—å")
        
        # Main container with padding
        container = ctk.CTkFrame(self.content_frame)
        container.grid(row=0, column=0, sticky="nsew", padx=40, pady=30)
        container.grid_columnconfigure(0, weight=1)
        
        # Title
        ctk.CTkLabel(
            container,
            text="–ó–∞–ø–∏—Å—å –≤—Å—Ç—Ä–µ—á–∏",
            font=("Segoe UI", 24, "bold")
        ).grid(row=0, column=0, pady=(0, 20))
        
        # Host selection
        ctk.CTkLabel(
            container, text="–í–µ–¥—É—â–∏–π –≤—Å—Ç—Ä–µ—á–∏:", font=("Segoe UI", 14)
        ).grid(row=1, column=0, sticky="w", pady=(0, 5))
        
        self.host_menu = ctk.CTkOptionMenu(
            container, values=[""], width=400, height=35
        )
        self.host_menu.grid(row=2, column=0, pady=(0, 20))
        self._refresh_host_menu()
        
        # Topic input
        ctk.CTkLabel(
            container, text="–¢–µ–º–∞ –≤—Å—Ç—Ä–µ—á–∏:", font=("Segoe UI", 14)
        ).grid(row=3, column=0, sticky="w", pady=(0, 5))
        
        self.topic_entry = ctk.CTkEntry(
            container, width=400, height=35, placeholder_text="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–º—É..."
        )
        self.topic_entry.grid(row=4, column=0, pady=(0, 20))
        
        # --- –í–ò–ó–£–ê–õ–ò–ó–ê–¢–û–† –ó–í–£–ö–ê ---
        self.vu_meter_frame = ctk.CTkFrame(container, fg_color="transparent")
        self.vu_meter_frame.grid(row=5, column=0, pady=(0, 10))
        
        ctk.CTkLabel(self.vu_meter_frame, text="–£—Ä–æ–≤–µ–Ω—å —Å–∏–≥–Ω–∞–ª–∞:").pack(anchor="w")
        self.vu_meter = ctk.CTkProgressBar(
            self.vu_meter_frame, 
            width=400, 
            height=15, 
            orientation="horizontal",
            mode="determinate"
        )
        self.vu_meter.pack(pady=5)
        self.vu_meter.set(0.0)
        # –°–∫—Ä—ã–≤–∞–µ–º, –ø–æ–∫–∞ –∑–∞–ø–∏—Å—å –Ω–µ –∏–¥–µ—Ç
        self.vu_meter_frame.grid_remove() 
        # ---------------------------

        # Timer
        self.timer_label = ctk.CTkLabel(
            container, text="00:00", font=("Segoe UI", 48, "bold")
        )
        self.timer_label.grid(row=6, column=0, pady=10)
        
        # Buttons Frame
        btn_frame = ctk.CTkFrame(container, fg_color="transparent")
        btn_frame.grid(row=7, column=0, pady=20)
        
        # Pause Button
        self.pause_button = ctk.CTkButton(
            btn_frame,
            text="‚è∏ –ü–∞—É–∑–∞",
            width=120,
            height=50,
            font=("Segoe UI", 14, "bold"),
            fg_color="#f39c12",
            hover_color="#d35400",
            state="disabled",
            command=self._toggle_pause
        )
        self.pause_button.pack(side="left", padx=10)

        # Record Button
        self.record_button = ctk.CTkButton(
            btn_frame,
            text="‚è∫ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å",
            width=200,
            height=60,
            font=("Segoe UI", 16, "bold"),
            fg_color="green",
            hover_color="#006400",
            command=self._toggle_recording
        )
        self.record_button.pack(side="left", padx=10)
        
        # Report button
        self.report_button_live = ctk.CTkButton(
            container,
            text="üìÑ –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç",
            width=300,
            height=50,
            font=("Segoe UI", 14),
            state="disabled",
            command=self._generate_report
        )
        self.report_button_live.grid(row=8, column=0, pady=10)
    
    def _show_analysis_page(self):
        """Show the analysis page with Audio Player"""
        self._clear_content()
        self._highlight_nav_button("üìä –ê–Ω–∞–ª–∏–∑")
        
        container = ctk.CTkFrame(self.content_frame)
        container.grid(row=0, column=0, sticky="nsew", padx=40, pady=30)
        container.grid_columnconfigure(0, weight=1)
        # –†—è–¥ 8 (–≥–¥–µ –ª–æ–≥) –¥–æ–ª–∂–µ–Ω —Ä–∞—Å—Ç—è–≥–∏–≤–∞—Ç—å—Å—è
        container.grid_rowconfigure(8, weight=1) 
        
        # Title
        ctk.CTkLabel(
            container,
            text="–ê–Ω–∞–ª–∏–∑ –∑–∞–ø–∏—Å–∏",
            font=("Segoe UI", 24, "bold")
        ).grid(row=0, column=0, pady=(0, 20))
        
        # File selection buttons
        btn_frame = ctk.CTkFrame(container, fg_color="transparent")
        btn_frame.grid(row=1, column=0, pady=5)
        
        ctk.CTkButton(
            btn_frame,
            text="üìÇ –í—ã–±—Ä–∞—Ç—å –∞—É–¥–∏–æ—Ñ–∞–π–ª",
            width=200,
            command=self._pick_file
        ).pack(side="left", padx=5)
        
        ctk.CTkButton(
            btn_frame,
            text="üìÑ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç",
            width=200,
            fg_color="#506673",
            command=self._pick_transcript_file
        ).pack(side="left", padx=5)
        
        self.selected_file_label = ctk.CTkLabel(container, text="", font=("Segoe UI", 12))
        self.selected_file_label.grid(row=2, column=0, pady=5)

        # === –ê–£–î–ò–û –ü–õ–ï–ï–† ===
        self.player_frame = ctk.CTkFrame(container)
        self.player_frame.grid(row=3, column=0, sticky="ew", pady=10)
        self.player_frame.grid_columnconfigure(1, weight=1)
        # –°–∫—Ä—ã–≤–∞–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–æ–∫–∞ —Ñ–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω
        self.player_frame.grid_remove()

        # –ö–Ω–æ–ø–∫–∞ Play/Pause
        self.player_btn = ctk.CTkButton(
            self.player_frame, text="‚ñ∂", width=40, height=40,
            font=("Segoe UI", 20),
            command=self._player_toggle
        )
        self.player_btn.grid(row=0, column=0, padx=10, pady=10)
        
        # –°–ª–∞–π–¥–µ—Ä (Seek bar)
        self.player_slider = ctk.CTkSlider(
            self.player_frame, from_=0, to=100,
            command=self._player_on_slide
        )
        self.player_slider.grid(row=0, column=1, sticky="ew", padx=10)
        self.player_slider.set(0)
        
        # –í—Ä–µ–º—è 00:00 / 00:00
        self.player_time_lbl = ctk.CTkLabel(
            self.player_frame, text="00:00 / 00:00", font=("Consolas", 12)
        )
        self.player_time_lbl.grid(row=0, column=2, padx=10)
        # ===================

        # Report buttons and Actions
        actions_frame = ctk.CTkFrame(container, fg_color="transparent")
        actions_frame.grid(row=4, column=0, pady=20)
        
        # Save Transcript Button
        self.save_transcript_btn = ctk.CTkButton(
            actions_frame,
            text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç",
            width=200,
            height=50,
            font=("Segoe UI", 13),
            state="disabled",
            command=self._save_transcript_changes
        )
        self.save_transcript_btn.pack(side="left", padx=5)
        
        # Link Files Button
        self.link_files_btn = ctk.CTkButton(
            actions_frame,
            text="üîó –ü—Ä–∏–≤—è–∑–∞—Ç—å —Ñ–∞–π–ª—ã",
            width=180,
            height=50,
            font=("Segoe UI", 13),
            command=self._show_link_files_dialog
        )
        self.link_files_btn.pack(side="left", padx=5)
        
        # Report Button
        self.report_button_file = ctk.CTkButton(
            actions_frame,
            text="üìÑ –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç",
            width=220,
            height=50,
            font=("Segoe UI", 14, "bold"),
            state="disabled",
            command=self._generate_report
        )
        self.report_button_file.pack(side="left", padx=5)
        
        # Log/Transcript
        ctk.CTkLabel(
            container,
            text="–°—Ç–µ–Ω–æ–≥—Ä–∞–º–º–∞ (–º–æ–∂–Ω–æ –ø—Ä–∞–≤–∏—Ç—å):",
            font=("Segoe UI", 14, "bold")
        ).grid(row=5, column=0, sticky="w", pady=(5, 5))
        
        # Scrollable frame for segments
        self.transcript_scroll = ctk.CTkScrollableFrame(
            container,
            height=400,
            label_text="–§—Ä–∞–≥–º–µ–Ω—Ç—ã"
        )
        self.transcript_scroll.grid(row=6, column=0, sticky="nsew", pady=5)
        self.transcript_scroll.grid_columnconfigure(0, weight=1)
        
        # Keep log_box for system messages, but smaller/hidden or separate tab?
        # Let's add a small log area below or make it a tab.
        # For now, let's keep it but minimized or accessible via toggle?
        # Or just log to status bar and console.
        # Let's add a "System Log" expander or just put it at the bottom.
        
        self.log_expander = ctk.CTkFrame(container)
        self.log_expander.grid(row=7, column=0, sticky="ew", pady=5)
        
        self.log_box_visible = False
        self.log_toggle_btn = ctk.CTkButton(
            self.log_expander,
            text="‚ñ∂ –ü–æ–∫–∞–∑–∞—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –ª–æ–≥",
            command=self._toggle_log_box,
            fg_color="transparent",
            text_color=("gray10", "gray90"),
            anchor="w"
        )
        self.log_toggle_btn.pack(fill="x")
        
        self.log_box = ctk.CTkTextbox(
            container,
            height=150,
            wrap="word",
            font=("Consolas", 10)
        )
        # Don't grid log_box initially

    
    def _show_voices_page(self):
        """Show the voices management page"""
        self._clear_content()
        self._highlight_nav_button("üó£Ô∏è –ì–æ–ª–æ—Å–∞")
        self.current_page = "voices"  # Track current page
        
        container = ctk.CTkScrollableFrame(self.content_frame)
        container.grid(row=0, column=0, sticky="nsew", padx=40, pady=30)
        container.grid_columnconfigure(0, weight=1)
        
        # Title
        ctk.CTkLabel(
            container,
            text="–ë–∞–∑–∞ –≥–æ–ª–æ—Å–æ–≤",
            font=("Segoe UI", 24, "bold")
        ).grid(row=0, column=0, pady=(0, 20), sticky="w")
        
        # Buttons
        btn_frame = ctk.CTkFrame(container, fg_color="transparent")
        btn_frame.grid(row=1, column=0, sticky="w", pady=10)
        
        ctk.CTkButton(
            btn_frame,
            text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≥–æ–ª–æ—Å",
            width=150,
            height=35,
            command=lambda: AddSpeakerDialog(
                self,
                self.voice_db,
                self.recorder,
                self.ai,
                self._log,
                lambda: self._show_voices_page()  # Refresh on change
            )
        ).pack(side="left", padx=5)
        
        ctk.CTkButton(
            btn_frame,
            text="üë• –ü–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å–æ –≤—Å–µ–º–∏",
            width=200,
            height=35,
            fg_color="#4c6ef5",
            hover_color="#3b5bdb",
            command=lambda: threading.Thread(target=self._train_all_speakers, daemon=True).start()
        ).pack(side="left", padx=5)
        
        # Speakers list with status
        row = 2
        for name, data in sorted(self.voice_db.items()):
            # Determine status
            if isinstance(data, dict):
                trained = data.get("trained", True)
                sample_count = data.get("sample_count", 0)
            else:
                # Old format (migration should have handled this)
                trained = True
                sample_count = self._get_speaker_sample_count(name)
            
            # Status icon and text
            if trained:
                icon = "‚úÖ"
                status_text = f"–æ–±—É—á–µ–Ω, {sample_count} —Å–µ–º–ø–ª(–æ–≤)"
                status_color = "#51cf66"
            elif sample_count > 0:
                icon = "‚ö†Ô∏è"
                status_text = f"–Ω–µ –æ–±—É—á–µ–Ω, {sample_count} —Å–µ–º–ø–ª(–æ–≤)"
                status_color = "#ffd43b"
            else:
                icon = "‚ùå"
                status_text = "–Ω–µ –æ–±—É—á–µ–Ω, 0 —Å–µ–º–ø–ª–æ–≤"
                status_color = "#ff6b6b"
            
            # Speaker row frame
            speaker_frame = ctk.CTkFrame(container)
            speaker_frame.grid(row=row, column=0, sticky="ew", pady=5, padx=10)
            speaker_frame.grid_columnconfigure(1, weight=1)
            
            # Icon + Name
            ctk.CTkLabel(
                speaker_frame,
                text=f"{icon} {name}",
                font=("Segoe UI", 14, "bold")
            ).grid(row=0, column=0, sticky="w", padx=10, pady=10)
            
            # Status
            ctk.CTkLabel(
                speaker_frame,
                text=status_text,
                font=("Segoe UI", 11),
                text_color=status_color
            ).grid(row=0, column=1, sticky="w", padx=10)
            
            # Quick train button (only if untrained but has samples)
            if not trained and sample_count > 0:
                ctk.CTkButton(
                    speaker_frame,
                    text="‚ö° –û–±—É—á–∏—Ç—å",
                    width=100,
                    height=28,
                    fg_color="#4c6ef5",
                    hover_color="#3b5bdb",
                    command=lambda n=name: threading.Thread(
                        target=self._quick_train_speaker, 
                        args=(n,), 
                        daemon=True
                    ).start()
                ).grid(row=0, column=2, padx=5)
            
            # Re-train button (if trained) - opens dialog to add new sample
            if trained:
                ctk.CTkButton(
                    speaker_frame,
                    text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–µ–º–ø–ª",
                    width=130,
                    height=28,
                    fg_color="#868e96",
                    hover_color="#6c757d",
                    command=lambda n=name: AddSpeakerDialog(
                        self,
                        self.voice_db,
                        self.recorder,
                        self.ai,
                        self._log,
                        lambda: self._retrain_after_sample(n),
                        existing_name=n
                    )
                ).grid(row=0, column=2, padx=5)
            
            # Rename button
            ctk.CTkButton(
                speaker_frame,
                text="‚úèÔ∏è",
                width=30,
                height=28,
                fg_color="#228be6",
                hover_color="#1c7ed6",
                command=lambda n=name: self._rename_speaker(n)
            ).grid(row=0, column=3, padx=5)
            
            # Delete button
            ctk.CTkButton(
                speaker_frame,
                text="üóëÔ∏è",
                width=30,
                height=28,
                fg_color="#c92a2a",
                hover_color="#a61e1e",
                command=lambda n=name: self._remove_speaker_by_name(n)
            ).grid(row=0, column=4, padx=5)
            
            row += 1
    
    def _show_settings_page(self):
        """Show settings page inline"""
        self._clear_content()
        self._highlight_nav_button("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
        
        # Main scrollable container to handle overflow
        container = ctk.CTkScrollableFrame(self.content_frame)
        container.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        container.grid_columnconfigure(0, weight=1)
        
        # Title
        ctk.CTkLabel(
            container,
            text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
            font=("Segoe UI", 24, "bold")
        ).grid(row=0, column=0, pady=(10, 20), sticky="w", padx=20)
        
        # Tabs
        tabs = ctk.CTkTabview(container)
        tabs.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0, 10))
        
        tab_sys = tabs.add("–°–∏—Å—Ç–µ–º–∞")
        tab_audio = tabs.add("–ê—É–¥–∏–æ")
        tab_stt = tabs.add("–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ")
        tab_llm = tabs.add("–ù–µ–π—Ä–æ—Å–µ—Ç—å")
        tab_export = tabs.add("–≠–∫—Å–ø–æ—Ä—Ç")
        
        # --- –°–ò–°–¢–ï–ú–ê ---
        self._build_settings_entry(tab_sys, "HF Token:", "hf_token", password=True)
        self._build_settings_entry(tab_sys, "–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):", "keywords")
        
        # Theme selector
        ctk.CTkLabel(
            tab_sys, text="–¢–µ–º–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(15, 5))
        self.settings_theme_var = ctk.StringVar(value=ctk.get_appearance_mode())
        ctk.CTkSegmentedButton(
            tab_sys,
            values=["Dark", "Light", "System"],
            variable=self.settings_theme_var,
            command=self._change_theme
        ).pack(fill="x", padx=20, pady=5)

        self.settings_remove_silence_var = ctk.BooleanVar(value=config.get("remove_silence", False))
        ctk.CTkCheckBox(
            tab_audio, 
            text="‚úÇÔ∏è –£–¥–∞–ª—è—Ç—å —Ç–∏—à–∏–Ω—É –∏–∑ –∑–∞–ø–∏—Å–∏ (VAD)", 
            variable=self.settings_remove_silence_var
        ).pack(anchor="w", padx=20, pady=10)
        
        if not FFmpegInstaller.is_installed():
            ctk.CTkButton(
                tab_sys,
                text="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å FFmpeg",
                command=lambda: threading.Thread(
                    target=lambda: FFmpegInstaller.install(self._log),
                    daemon=True,
                ).start(),
            ).pack(pady=10, padx=20)
        
        # --- –ê–£–î–ò–û ---
        # --- –ê–£–î–ò–û ---
        ctk.CTkLabel(
            tab_audio, text="–í—Ö–æ–¥–Ω–æ–π –º–∏–∫—Ä–æ—Ñ–æ–Ω:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(10, 5))
        
        self.settings_device_var = ctk.StringVar(value=config.get("input_device"))
        devices = AudioHelper.get_devices() or ["Default"]
        
        # –§—Ä–µ–π–º –¥–ª—è –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ –∏ –∫–Ω–æ–ø–∫–∏ —Ç–µ—Å—Ç–∞
        mic_frame = ctk.CTkFrame(tab_audio, fg_color="transparent")
        mic_frame.pack(fill="x", padx=20, pady=5)
        
        ctk.CTkOptionMenu(
            mic_frame, variable=self.settings_device_var, values=devices, width=300
        ).pack(side="left", padx=(0, 10))
        
        ctk.CTkButton(
            mic_frame, 
            text="üîä –¢–µ—Å—Ç", 
            width=80,
            fg_color="#506673",
            command=self._open_mic_tester
        ).pack(side="left")
        
        ctk.CTkLabel(
            tab_audio, text="–§–æ—Ä–º–∞—Ç –∑–∞–ø–∏—Å–∏:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(15, 5))
        self.settings_rec_format_var = ctk.StringVar(value=config.get("rec_format"))
        ctk.CTkSegmentedButton(
            tab_audio,
            values=["wav", "mp3"],
            variable=self.settings_rec_format_var,
        ).pack(fill="x", padx=20, pady=5)
        
        # --- –†–ê–°–ü–û–ó–ù–ê–í–ê–ù–ò–ï (STT) ---
        ctk.CTkLabel(
            tab_stt, text="–†–µ–∂–∏–º –æ–±—Ä–∞–±–æ—Ç–∫–∏:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(10, 5))
        self.settings_processing_mode_var = ctk.StringVar(
            value=config.get("processing_mode")
        )
        ctk.CTkSegmentedButton(
            tab_stt,
            values=["cloud", "local"],
            variable=self.settings_processing_mode_var,
            command=self._settings_switch_stt_mode,
        ).pack(fill="x", padx=20, pady=5)
        
        # Cloud-specific settings frame
        self.settings_frame_cloud_stt = ctk.CTkFrame(tab_stt)
        
        self.settings_cloud_use_mp3 = ctk.BooleanVar(
            value=config.get("cloud_use_mp3")
        )
        ctk.CTkCheckBox(
            self.settings_frame_cloud_stt,
            text="–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å –≤ Deepgram –≤ –≤–∏–¥–µ MP3",
            variable=self.settings_cloud_use_mp3,
        ).pack(anchor="w", padx=20, pady=5)
        
        self._build_settings_entry(self.settings_frame_cloud_stt, "–ö–ª—é—á Deepgram:", "deepgram_key", password=True)
        
        ctk.CTkButton(
            tab_stt,
            text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –º–æ–¥–µ–ª–∏ (Integrity Check)",
            command=self._settings_check_integrity
        ).pack(pady=10, padx=20)
        
        ctk.CTkLabel(
            tab_stt, text="–õ–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å Whisper:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(15, 5))
        self.settings_local_size_var = ctk.StringVar(
            value=config.get("local_model_size")
        )
        ctk.CTkOptionMenu(
            tab_stt,
            variable=self.settings_local_size_var,
            values=["tiny", "base", "small", "medium", "large-v3"],
        ).pack(fill="x", padx=20, pady=5)
        
        # Batch size slider
        ctk.CTkLabel(
            tab_stt, text="–†–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞ (batch size):", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(15, 5))
        
        self.settings_batch_size_var = ctk.IntVar(value=config.get("batch_size", 8))
        
        batch_frame = ctk.CTkFrame(tab_stt)
        batch_frame.pack(fill="x", padx=20, pady=5)
        
        self.settings_batch_size_label = ctk.CTkLabel(
            batch_frame, text=f"–ó–Ω–∞—á–µ–Ω–∏–µ: {self.settings_batch_size_var.get()}"
        )
        self.settings_batch_size_label.pack(side="left", padx=10)
        
        self.settings_batch_size_slider = ctk.CTkSlider(
            batch_frame,
            from_=1,
            to=32,
            number_of_steps=31,
            variable=self.settings_batch_size_var,
            command=self._settings_update_batch_label
        )
        self.settings_batch_size_slider.pack(side="left", fill="x", expand=True, padx=10)
        
        # Show/hide cloud settings based on mode
        self._settings_switch_stt_mode(self.settings_processing_mode_var.get())
        
        # --- –ù–ï–ô–†–û–°–ï–¢–¨ (LLM) ---
        ctk.CTkLabel(
            tab_llm, text="–ü—Ä–æ–≤–∞–π–¥–µ—Ä LLM:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w", padx=20, pady=(10, 5))
        self.settings_llm_provider_var = ctk.StringVar(
            value=config.get("llm_provider")
        )
        ctk.CTkSegmentedButton(
            tab_llm,
            values=["openrouter", "local"],
            variable=self.settings_llm_provider_var,
            command=self._settings_switch_llm_provider,
        ).pack(fill="x", padx=20, pady=5)
        
        # OpenRouter frame
        self.settings_frame_or = ctk.CTkFrame(tab_llm)
        self._build_settings_entry(self.settings_frame_or, "OpenRouter API key:", "or_key", password=True)
        
        ctk.CTkLabel(self.settings_frame_or, text="–ú–æ–¥–µ–ª—å OpenRouter:").pack(anchor="w", padx=10)
        self.settings_or_model_var = ctk.StringVar(value=config.get("or_model"))
        self.settings_or_model_combo = ctk.CTkComboBox(
            self.settings_frame_or,
            variable=self.settings_or_model_var,
            values=[config.get("or_model")] if config.get("or_model") else [],
            width=300
        )
        self.settings_or_model_combo.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkButton(
            self.settings_frame_or,
            text="–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π",
            command=self._settings_load_or_models
        ).pack(pady=5)
        
        # Local LLM frame
        self.settings_frame_local_llm = ctk.CTkFrame(tab_llm)
        
        # Check if Ollama is installed
        ollama_installed = OllamaManager.is_installed()
        
        if not ollama_installed:
            # Show warning if Ollama not installed
            warning_frame = ctk.CTkFrame(self.settings_frame_local_llm, fg_color=("#f39c12", "#e67e22"))
            warning_frame.pack(fill="x", padx=10, pady=10)
            
            ctk.CTkLabel(
                warning_frame,
                text="‚ö† Ollama –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞",
                font=("Segoe UI", 13, "bold"),
                text_color="white"
            ).pack(anchor="w", padx=10, pady=(10, 5))
            
            ctk.CTkLabel(
                warning_frame,
                text="–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å Ollama.",
                text_color="white",
                wraplength=400
            ).pack(anchor="w", padx=10, pady=(0, 5))
            
            ctk.CTkButton(
                warning_frame,
                text="üåê –°–∫–∞—á–∞—Ç—å Ollama",
                command=lambda: self._open_url("https://ollama.com/download"),
                fg_color="white",
                text_color="black",
                hover_color="#ecf0f1"
            ).pack(anchor="w", padx=10, pady=(5, 10))
        
        ctk.CTkLabel(
            self.settings_frame_local_llm,
            text="–õ–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å (Ollama):",
        ).pack(anchor="w", padx=10, pady=(5, 0))
        self.settings_local_model_var = ctk.StringVar(
            value=config.get("local_model")
        )
        models = OllamaManager.get_local_models() or ["None"]
        self.settings_local_model_menu = ctk.CTkOptionMenu(
            self.settings_frame_local_llm,
            variable=self.settings_local_model_var,
            values=models,
        )
        self.settings_local_model_menu.pack(fill="x", padx=10, pady=5)
        
        # Only show model shop if Ollama is installed
        if ollama_installed:
            # Collapsible Ollama Model Shop
            self.settings_shop_expanded = ctk.BooleanVar(value=False)
            
            shop_header = ctk.CTkFrame(self.settings_frame_local_llm)
            shop_header.pack(fill="x", padx=10, pady=(10, 0))
            
            self.settings_shop_toggle_btn = ctk.CTkButton(
                shop_header,
                text="‚ñ∂ –ú–∞–≥–∞–∑–∏–Ω –º–æ–¥–µ–ª–µ–π",
                command=self._settings_toggle_shop,
                width=200,
                fg_color="transparent",
                hover_color=("gray70", "gray30"),
                anchor="w"
            )
            self.settings_shop_toggle_btn.pack(side="left", fill="x", expand=True)
            
            # Shop content (initially hidden)
            self.settings_shop_frame = ctk.CTkScrollableFrame(
                self.settings_frame_local_llm, 
                height=300,
                label_text="–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏ Ollama"
            )
            # Don't pack yet, will be packed/unpacked on toggle
            
            # Build shop content
            self._build_ollama_shop_content()
        
        self._settings_switch_llm_provider(self.settings_llm_provider_var.get())
        
        # --- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø—Ä–æ–º–ø—Ç–æ–≤ ---
        # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
        ctk.CTkFrame(tab_llm, height=2, fg_color="gray50").pack(fill="x", padx=10, pady=10)

        frame_tokens = ctk.CTkFrame(tab_llm, fg_color="transparent")
        frame_tokens.pack(fill="x", padx=20, pady=(5, 0))
        
        self.settings_enable_token_limit_var = ctk.BooleanVar(value=config.get("enable_token_limit", True))
        ctk.CTkCheckBox(
            frame_tokens, 
            text="–ê–≤—Ç–æ-—Ä–∞–∑–±–∏–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –ª–∏–º–∏—Ç–∞:", 
            variable=self.settings_enable_token_limit_var,
            font=("Segoe UI", 12, "bold")
        ).pack(side="left")
        
        self.settings_token_limit_entry = ctk.CTkEntry(tab_llm, placeholder_text="12000")
        self.settings_token_limit_entry.pack(fill="x", padx=20, pady=(5, 10))
        self.settings_token_limit_entry.insert(0, str(config.get("llm_token_limit")))

        # --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ 2: –†–∞–∑–±–∏–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ ---
        frame_chunks = ctk.CTkFrame(tab_llm, fg_color="transparent")
        frame_chunks.pack(fill="x", padx=20, pady=(5, 0))

        self.settings_force_time_split_var = ctk.BooleanVar(value=config.get("force_time_split", False))
        ctk.CTkCheckBox(
            frame_chunks, 
            text="–í—Å–µ–≥–¥–∞ —Ä–∞–∑–±–∏–≤–∞—Ç—å –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏:", 
            variable=self.settings_force_time_split_var,
            font=("Segoe UI", 12, "bold")
        ).pack(side="left")
        
        self.settings_chunk_minutes_entry = ctk.CTkEntry(tab_llm, placeholder_text="55")
        self.settings_chunk_minutes_entry.pack(fill="x", padx=20, pady=(5, 10))
        self.settings_chunk_minutes_entry.insert(0, str(config.get("chunk_minutes")))
        
        # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
        ctk.CTkFrame(tab_llm, height=2, fg_color="gray50").pack(fill="x", padx=10, pady=10)
        # --------------------------------
        frame_prompts = ctk.CTkFrame(tab_llm)
        frame_prompts.pack(fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(
            frame_prompts, text="–°—Ü–µ–Ω–∞—Ä–∏–π –æ—Ç—á—ë—Ç–∞:", font=("Segoe UI", 12, "bold")
        ).pack(anchor="w")
        
        self.settings_prompts_map = BUILTIN_PROMPTS.copy()
        self.settings_prompts_map.update(config.get("custom_prompts") or {})
        
        self.settings_current_prompt_name_var = ctk.StringVar(
            value=config.get("current_prompt_name")
        )
        self.settings_prompts_menu = ctk.CTkOptionMenu(
            frame_prompts,
            variable=self.settings_current_prompt_name_var,
            values=list(self.settings_prompts_map.keys()),
            command=self._settings_select_prompt,
            width=320,
        )
        self.settings_prompts_menu.pack(pady=5)
        
        self.settings_prompt_text = ctk.CTkTextbox(tab_llm, height=150)
        self.settings_prompt_text.pack(fill="x", padx=20, pady=5)
        self.settings_prompt_text.insert("0.0", config.get("system_prompt") or "")
        
        frame_prompt_buttons = ctk.CTkFrame(tab_llm)
        frame_prompt_buttons.pack(pady=5)
        self.settings_prompt_name_entry = ctk.CTkEntry(
            frame_prompt_buttons, width=180, placeholder_text="–ò–º—è –Ω–æ–≤–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è..."
        )
        self.settings_prompt_name_entry.pack(side="left", padx=5)
        ctk.CTkButton(
            frame_prompt_buttons,
            text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ –Ω–æ–≤—ã–π",
            command=self._settings_save_prompt,
        ).pack(side="left", padx=5)
        ctk.CTkButton(
            frame_prompt_buttons,
            text="–£–¥–∞–ª–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π",
            fg_color="red",
            command=self._settings_delete_prompt,
        ).pack(side="left", padx=5)
        
        # --- –≠–ö–°–ü–û–†–¢ ---
        self.settings_save_txt_var = ctk.BooleanVar(value=config.get("save_txt"))
        self.settings_save_docx_var = ctk.BooleanVar(value=config.get("save_docx"))
        ctk.CTkCheckBox(
            tab_export, text="–°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—É (.txt)", variable=self.settings_save_txt_var
        ).pack(anchor="w", padx=20, pady=5)
        ctk.CTkCheckBox(
            tab_export, text="–°–æ—Ö—Ä–∞–Ω—è—Ç—å –æ—Ç—á—ë—Ç (.docx)", variable=self.settings_save_docx_var
        ).pack(anchor="w", padx=20, pady=5)
        
        if GDRIVE_AVAILABLE:
            self.settings_use_gdrive_var = ctk.BooleanVar(
                value=config.get("use_gdrive")
            )
            gdrive_cb = ctk.CTkCheckBox(
                tab_export,
                text="–ó–∞–≥—Ä—É–∂–∞—Ç—å —Ñ–∞–π–ª—ã –Ω–∞ Google Drive",
                variable=self.settings_use_gdrive_var,
                command=self._settings_on_gdrive_toggle,
            )
            gdrive_cb.pack(anchor="w", padx=20, pady=5)
        
        # Save button at bottom
        ctk.CTkButton(
            container, 
            text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏", 
            command=self._settings_save,
            width=200,
            height=40,
            font=("Segoe UI", 14, "bold")
        ).grid(row=2, column=0, pady=20)
    
    # === SETTINGS HELPER METHODS ===
    
    def _build_settings_entry(self, parent, label_text, config_key, password=False):
        """Helper to build a settings entry field"""
        frame = ctk.CTkFrame(parent)
        frame.pack(fill="x", padx=10, pady=5)
        ctk.CTkLabel(frame, text=label_text, width=220).pack(
            side="left", padx=(10, 5)
        )
        entry = ctk.CTkEntry(frame, show="*" if password else "")
        entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
        entry.insert(0, config.get(config_key, ""))
        setattr(self, f"settings_entry_{config_key}", entry)

    def _open_mic_tester(self):
        """–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ–∫–Ω–æ –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞"""
        dev = self.settings_device_var.get()
        # –ü–µ—Ä–µ–¥–∞–µ–º self –∫–∞–∫ —Ä–æ–¥–∏—Ç–µ–ª—è –∏ –∏–º—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        MicTesterWindow(self, dev)
    
    def _open_url(self, url: str):
        """Open URL in default browser"""
        import webbrowser
        webbrowser.open(url)
        self._log(f"–û—Ç–∫—Ä—ã—Ç–∞ —Å—Å—ã–ª–∫–∞: {url}")
    
    def _change_theme(self, mode: str):
        """Change the UI theme"""
        ctk.set_appearance_mode(mode)
        self._log(f"–¢–µ–º–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: {mode}")
    
    def _settings_switch_stt_mode(self, mode: str):
        """Show/hide cloud-specific settings based on STT mode"""
        self.settings_frame_cloud_stt.pack_forget()
        if mode == "cloud":
            self.settings_frame_cloud_stt.pack(fill="x", padx=10, pady=5)
    
    def _settings_switch_llm_provider(self, provider: str):
        """Toggle between OpenRouter and local LLM settings"""
        self.settings_frame_or.pack_forget()
        self.settings_frame_local_llm.pack_forget()
        if provider == "openrouter":
            self.settings_frame_or.pack(fill="x", padx=10, pady=5)
        else:
            self.settings_frame_local_llm.pack(fill="x", padx=10, pady=5)
    
    def _settings_select_prompt(self, name: str):
        """Load selected prompt into text area"""
        text = self.settings_prompts_map.get(name, "")
        self.settings_prompt_text.delete("0.0", "end")
        self.settings_prompt_text.insert("0.0", text)
    
    def _settings_save_prompt(self):
        """Save custom prompt"""
        name = self.settings_prompt_name_entry.get().strip()
        text = self.settings_prompt_text.get("0.0", "end").strip()
        if not name or name in BUILTIN_PROMPTS:
            return
        custom = config.get("custom_prompts") or {}
        custom[name] = text
        config.set("custom_prompts", custom)
        config.save()
        
        self.settings_prompts_map = BUILTIN_PROMPTS.copy()
        self.settings_prompts_map.update(custom)
        self.settings_prompts_menu.configure(values=list(self.settings_prompts_map.keys()))
        self.settings_current_prompt_name_var.set(name)
        self._log(f"–°—Ü–µ–Ω–∞—Ä–∏–π '{name}' —Å–æ—Ö—Ä–∞–Ω—ë–Ω")
    
    def _settings_delete_prompt(self):
        """Delete custom prompt"""
        name = self.settings_current_prompt_name_var.get()
        if name in BUILTIN_PROMPTS:
            messagebox.showwarning("–£–¥–∞–ª–µ–Ω–∏–µ", "–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –Ω–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å")
            return
        custom = config.get("custom_prompts") or {}
        if name in custom:
            custom.pop(name)
            config.set("custom_prompts", custom)
            config.save()
        self.settings_prompts_map = BUILTIN_PROMPTS.copy()
        self.settings_prompts_map.update(custom)
        self.settings_prompts_menu.configure(values=list(self.settings_prompts_map.keys()))
        self.settings_current_prompt_name_var.set("–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π (—É–º–Ω—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª)")
        self._settings_select_prompt("–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π (—É–º–Ω—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª)")
        self._log(f"–°—Ü–µ–Ω–∞—Ä–∏–π '{name}' —É–¥–∞–ª—ë–Ω")
    
    def _settings_update_batch_label(self, value):
        """Update batch size label when slider changes"""
        self.settings_batch_size_label.configure(text=f"–ó–Ω–∞—á–µ–Ω–∏–µ: {int(float(value))}")
    
    def _settings_load_or_models(self):
        """Load OpenRouter models list"""
        models = fetch_openrouter_models()
        if models:
            self.settings_or_model_combo.configure(values=models)
            if not self.settings_or_model_var.get():
                self.settings_or_model_var.set(models[0])
            messagebox.showinfo("OpenRouter", f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(models)} –º–æ–¥–µ–ª–µ–π.")
        else:
            messagebox.showerror("OpenRouter", "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π.")
    
    def _settings_check_integrity(self):
        """Check model integrity"""
        win = ctk.CTkToplevel(self)
        win.title("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏")
        win.geometry("500x400")
        
        log_box = ctk.CTkTextbox(win)
        log_box.pack(fill="both", expand=True, padx=10, pady=10)
        
        def log(msg):
            try:
                if not win.winfo_exists():
                    return
                
                def _update():
                    try:
                        if win.winfo_exists():
                            log_box.insert("end", msg + "\n")
                            log_box.see("end")
                    except Exception:
                        pass
                
                win.after(0, _update)
            except Exception:
                pass
        
        threading.Thread(
            target=lambda: AIProcessor().check_models_integrity(log),
            daemon=True
        ).start()
    
    def _settings_on_gdrive_toggle(self):
        """Handle Google Drive toggle"""
        if self.settings_use_gdrive_var.get():
            def test_auth():
                gdrive = GDriveClient(self._log)
                if not gdrive.auth():
                    self.after(0, lambda: messagebox.showwarning(
                        "Google Drive",
                        "–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è.\n"
                        "–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª credentials.json –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø–∞–ø–∫–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã."
                    ))
                    self.after(0, lambda: self.settings_use_gdrive_var.set(False))
            threading.Thread(target=test_auth, daemon=True).start()
    
    def _settings_toggle_shop(self):
        """Toggle Ollama model shop visibility"""
        is_expanded = self.settings_shop_expanded.get()
        
        if is_expanded:
            # Collapse
            self.settings_shop_frame.pack_forget()
            self.settings_shop_toggle_btn.configure(text="‚ñ∂ –ú–∞–≥–∞–∑–∏–Ω –º–æ–¥–µ–ª–µ–π")
            self.settings_shop_expanded.set(False)
        else:
            # Expand
            self.settings_shop_frame.pack(fill="both", padx=10, pady=5)
            self.settings_shop_toggle_btn.configure(text="‚ñº –ú–∞–≥–∞–∑–∏–Ω –º–æ–¥–µ–ª–µ–π")
            self.settings_shop_expanded.set(True)
            # Refresh installed models when opening
            self._refresh_ollama_shop()
    
    def _build_ollama_shop_content(self):
        """Build the Ollama model shop content with categories"""
        # Get installed models (full names like 'gpt-oss:20b')
        installed_models_full = OllamaManager.get_local_models() or []
        
        # Helper to check if a model ID is installed (handles versions)
        def is_model_installed(model_id):
            # Check if any installed model starts with this ID
            return any(installed.startswith(model_id) for installed in installed_models_full)
        
        # Progress bar for downloads
        self.settings_shop_progress = ctk.CTkProgressBar(self.settings_shop_frame, mode="determinate")
        self.settings_shop_progress.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        self.settings_shop_progress.set(0.0)
        self.settings_shop_progress.grid_remove()  # Hidden by default
        
        self.settings_shop_status = ctk.CTkLabel(self.settings_shop_frame, text="")
        self.settings_shop_status.grid(row=1, column=0, sticky="w", padx=5)
        
        # Create tabs for categories
        row_offset = 2
        for group_name, models in OLLAMA_MODELS.items():
            # Category header
            cat_frame = ctk.CTkFrame(self.settings_shop_frame)
            cat_frame.grid(row=row_offset, column=0, sticky="ew", padx=5, pady=(15, 5))
            
            ctk.CTkLabel(
                cat_frame, 
                text=group_name, 
                font=("Segoe UI", 13, "bold")
            ).pack(anchor="w", padx=5, pady=5)
            
            row_offset += 1
            
            # Models in category
            for m in models:
                model_id = m["id"]
                is_installed = is_model_installed(model_id)
                
                model_frame = ctk.CTkFrame(self.settings_shop_frame)
                model_frame.grid(row=row_offset, column=0, sticky="ew", padx=5, pady=2)
                
                # Model name with indicator
                name_text = f"‚úì {m['name']}" if is_installed else m["name"]
                label_color = ("#2ecc71", "#27ae60") if is_installed else ("gray10", "gray90")
                
                ctk.CTkLabel(
                    model_frame,
                    text=name_text,
                    text_color=label_color,
                    width=200,
                    anchor="w"
                ).pack(side="left", padx=5)
                
                # Select button
                ctk.CTkButton(
                    model_frame,
                    text="–í—ã–±—Ä–∞—Ç—å",
                    width=80,
                    command=lambda mid=model_id: self._settings_select_ollama_model(mid),
                    state="normal" if is_installed else "disabled"
                ).pack(side="right", padx=2)
                
                # Download button
                download_text = "–û–±–Ω–æ–≤–∏—Ç—å" if is_installed else "–°–∫–∞—á–∞—Ç—å"
                ctk.CTkButton(
                    model_frame,
                    text=download_text,
                    width=80,
                    command=lambda mid=model_id: self._settings_download_ollama_model(mid)
                ).pack(side="right", padx=2)
                
                row_offset += 1
    
    def _refresh_ollama_shop(self):
        """Refresh Ollama shop to update installed model indicators"""
        # Clear all model frames (keep progress and status)
        for widget in self.settings_shop_frame.winfo_children():
            if isinstance(widget, ctk.CTkFrame):
                widget.destroy()
        
        # Rebuild content
        self._build_ollama_shop_content()
    
    def _settings_select_ollama_model(self, model_id: str):
        """Select an Ollama model"""
        self.settings_local_model_var.set(model_id)
        self.settings_shop_status.configure(text=f"–í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {model_id}")
        self._log(f"–í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å Ollama: {model_id}")
    
    def _settings_download_ollama_model(self, model_id: str):
        """Download an Ollama model"""
        if not OllamaManager.is_installed():
            messagebox.showerror(
                "Ollama",
                "Ollama –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ PATH.",
            )
            return
        
        self.settings_shop_progress.grid()
        self.settings_shop_progress.set(0.0)
        self.settings_shop_status.configure(text=f"–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ {model_id}...")
        
        def on_progress(frac, msg):
            self.after(0, lambda: (
                self.settings_shop_progress.set(frac),
                self.settings_shop_status.configure(text=msg)
            ))
        
        def on_done(success, mid):
            def ui():
                if success:
                    self.settings_shop_progress.set(1.0)
                    self.settings_shop_status.configure(text=f"–ú–æ–¥–µ–ª—å {mid} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞!")
                    # Auto-select the model
                    self.settings_local_model_var.set(mid)
                    # Refresh shop UI
                    self.after(500, self._refresh_ollama_shop)
                    # Hide progress after a delay
                    self.after(3000, lambda: self.settings_shop_progress.grid_remove())
                else:
                    self.settings_shop_status.configure(text=f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ {mid}")
                    self.settings_shop_progress.grid_remove()
            
            self.after(0, ui)
        
        threading.Thread(
            target=lambda: OllamaManager.pull_model(model_id, on_progress, on_done),
            daemon=True
        ).start()
    
    def _settings_save(self):
        """Save all settings"""
        # System
        config.set("hf_token", self.settings_entry_hf_token.get())
        config.set("keywords", self.settings_entry_keywords.get())
        
        # Audio
        config.set("input_device", self.settings_device_var.get())
        config.set("rec_format", self.settings_rec_format_var.get())
        config.set("remove_silence", self.settings_remove_silence_var.get())
        
        # STT
        config.set("processing_mode", self.settings_processing_mode_var.get())
        config.set("cloud_use_mp3", self.settings_cloud_use_mp3.get())
        config.set("deepgram_key", self.settings_entry_deepgram_key.get())
        config.set("local_model_size", self.settings_local_size_var.get())
        config.set("batch_size", self.settings_batch_size_var.get())
        
        # LLM
        config.set("llm_provider", self.settings_llm_provider_var.get())
        config.set("or_key", self.settings_entry_or_key.get())
        config.set("or_model", self.settings_or_model_var.get())
        config.set("local_model", self.settings_local_model_var.get())
        try:
            # 1. –°—á–∏—Ç—ã–≤–∞–µ–º —á–∏—Å–ª–∞ –∏–∑ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
            t_limit = int(self.settings_token_limit_entry.get().strip())
            c_min = int(self.settings_chunk_minutes_entry.get().strip())
            
            # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —á–∏—Å–ª–∞ –∞–¥–µ–∫–≤–∞—Ç–Ω—ã–µ
            if t_limit < 1000:
                messagebox.showwarning("–ù–∞—Å—Ç—Ä–æ–π–∫–∏", "–õ–∏–º–∏—Ç —Ç–æ–∫–µ–Ω–æ–≤ —Å–ª–∏—à–∫–æ–º –º–∞–ª (–º–∏–Ω. 1000).")
                return
            if c_min < 1:
                messagebox.showwarning("–ù–∞—Å—Ç—Ä–æ–π–∫–∏", "–ú–∏–Ω—É—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å > 0.")
                return

            # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º —á–∏—Å–ª–∞ –≤ –∫–æ–Ω—Ñ–∏–≥
            config.set("llm_token_limit", t_limit)
            config.set("chunk_minutes", c_min)
            
            # 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–æ–≤—ã—Ö —á–µ–∫–±–æ–∫—Å–æ–≤ (True/False)
            config.set("enable_token_limit", self.settings_enable_token_limit_var.get())
            config.set("force_time_split", self.settings_force_time_split_var.get())
            
        except ValueError:
            # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–µ–ª –±—É–∫–≤—ã –≤–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä
            messagebox.showerror("–û—à–∏–±–∫–∞", "–õ–∏–º–∏—Ç —Ç–æ–∫–µ–Ω–æ–≤ –∏ –º–∏–Ω—É—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ü–µ–ª—ã–º–∏ —á–∏—Å–ª–∞–º–∏.")
            return

        
        # Prompts
        config.set("current_prompt_name", self.settings_current_prompt_name_var.get())
        config.set("system_prompt", self.settings_prompt_text.get("0.0", "end").strip())
        
        # Export
        config.set("save_txt", self.settings_save_txt_var.get())
        config.set("save_docx", self.settings_save_docx_var.get())
        if GDRIVE_AVAILABLE:
            config.set("use_gdrive", self.settings_use_gdrive_var.get())
        
        config.save()
        messagebox.showinfo("–ù–∞—Å—Ç—Ä–æ–π–∫–∏", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!")
        self._log("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")
    
    def _show_files_page(self):
        """Show files browser page with tabs, filters, and search"""
        self._clear_content()
        self._highlight_nav_button("üìÅ –§–∞–π–ª—ã")
        
        # Main container
        container = ctk.CTkFrame(self.content_frame)
        container.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        container.grid_columnconfigure(0, weight=1)
        container.grid_rowconfigure(2, weight=1)  # Table row expands
        
        # === HEADER WITH SEARCH AND CLEAR ===
        header = ctk.CTkFrame(container)
        header.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
        header.grid_columnconfigure(1, weight=1)
        
        # Search buttons
        self.files_search_global_btn = ctk.CTkButton(
            header, text="üîç –ü–æ–∏—Å–∫ –≤–µ–∑–¥–µ",
            command=lambda: self._files_activate_search("global"),
            width=150
        )
        self.files_search_global_btn.grid(row=0, column=0, padx=5)
        
        self.files_search_user_btn = ctk.CTkButton(
            header, text="üîç –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            command=lambda: self._files_activate_search("user"),
            width=150
        )
        self.files_search_user_btn.grid(row=0, column=1, padx=5, sticky="w")
        
        # Search entry (hidden by default)
        self.files_search_var = ctk.StringVar()
        self.files_search_var.trace_add("write", lambda *args: self._files_refresh_list())
        self.files_search_entry = ctk.CTkEntry(
            header, textvariable=self.files_search_var,
            placeholder_text="–í–≤–µ–¥–∏—Ç–µ –∑–∞–ø—Ä–æ—Å...",
            width=300
        )
        # Don't grid yet
        
        # Clear filters button (right side)
        self.files_clear_btn = ctk.CTkButton(
            header, text="‚úñ –û—á–∏—Å—Ç–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã",
            command=self._files_clear_filters,
            fg_color="#e74c3c",
            hover_color="#c0392b",
            width=180
        )
        self.files_clear_btn.grid(row=0, column=3, padx=5, sticky="e")
        header.grid_columnconfigure(2, weight=1)  # Spacer
        
        # === FILTERS ROW ===
        filters = ctk.CTkFrame(container)
        filters.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        
        # File type filter
        ctk.CTkLabel(filters, text="–¢–∏–ø:").pack(side="left", padx=(10, 5))
        self.files_type_var = ctk.StringVar(value="–í—Å–µ")
        self.files_type_var.trace_add("write", lambda *args: self._files_refresh_list())
        ctk.CTkSegmentedButton(
            filters,
            values=["–í—Å–µ", "–ó–∞–ø–∏—Å–∏", "–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏", "–û—Ç—á–µ—Ç—ã"],
            variable=self.files_type_var
        ).pack(side="left", padx=5)
        
        # Sort filter
        ctk.CTkLabel(filters, text="–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:").pack(side="left", padx=(20, 5))
        self.files_sort_var = ctk.StringVar(value="–î–∞—Ç–∞ ‚Üì")
        self.files_sort_var.trace_add("write", lambda *args: self._files_refresh_list())
        ctk.CTkOptionMenu(
            filters,
            variable=self.files_sort_var,
            values=["–î–∞—Ç–∞ ‚Üì", "–î–∞—Ç–∞ ‚Üë", "–ò–º—è A-Z", "–ò–º—è Z-A"],
            width=120
        ).pack(side="left", padx=5)
        
        # Period filter
        ctk.CTkLabel(filters, text="–ü–µ—Ä–∏–æ–¥:").pack(side="left", padx=(20, 5))
        self.files_period_var = ctk.StringVar(value="–í—Å–µ")
        self.files_period_var.trace_add("write", lambda *args: self._files_refresh_list())
        ctk.CTkOptionMenu(
            filters,
            variable=self.files_period_var,
            values=["–í—Å–µ", "–°–µ–≥–æ–¥–Ω—è", "–ù–µ–¥–µ–ª—è", "–ú–µ—Å—è—Ü"],
            width=100
        ).pack(side="left", padx=5)
        
        # === HOST TABS (Scrollable) ===
        # Will be filled by _files_build_host_tabs()
        self.files_tabs_frame = ctk.CTkFrame(container)
        self.files_tabs_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=(10, 5))
        
        # === FILES TABLE ===
        self.files_table_frame = ctk.CTkScrollableFrame(container, height=400)
        self.files_table_frame.grid(row=3, column=0, sticky="nsew", padx=10, pady=5)
        self.files_table_frame.grid_columnconfigure(0, weight=1)
        
        # Initialize state variables
        self.files_current_host = "–í—Å–µ —Ñ–∞–π–ª—ã"
        self.files_search_mode = None  # None, "global", "user"
        self.files_all_files = []
        
        # Scan and build
        self._files_scan_all()
        self._files_build_host_tabs()
        self._files_refresh_list()
    
    # === FILES BROWSER HELPER METHODS ===
    
    def _files_scan_all(self):
        """Scan all files in Meeting_Records directory"""
        self.files_all_files = []
        
        if not os.path.exists(RECORDS_DIR):
            return
        
        # Iterate through host directories
        for host_name in os.listdir(RECORDS_DIR):
            host_path = os.path.join(RECORDS_DIR, host_name)
            if not os.path.isdir(host_path):
                continue
            
            # Scan each subdirectory
            for subdir_name, file_type in [
                ("–ó–∞–ø–∏—Å–∏", "recording"),
                ("–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏", "transcript"),
                ("–û—Ç—á–µ—Ç—ã", "report")
            ]:
                subdir_path = os.path.join(host_path, subdir_name)
                if not os.path.exists(subdir_path):
                    continue
                
                for filename in os.listdir(subdir_path):
                    filepath = os.path.join(subdir_path, filename)
                    if not os.path.isfile(filepath):
                        continue
                    
                    # Get file stats
                    try:
                        stats = os.stat(filepath)
                        file_date = datetime.fromtimestamp(stats.st_mtime)
                        file_size = stats.st_size
                        
                        self.files_all_files.append({
                            "path": filepath,
                            "name": filename,
                            "host": host_name,
                            "type": file_type,
                            "date": file_date,
                            "size": file_size
                        })
                    except Exception:
                        continue
    
    def _files_build_host_tabs(self):
        """Build scrollable host tabs"""
        # Clear existing tabs
        for widget in self.files_tabs_frame.winfo_children():
            widget.destroy()
        
        # Get unique hosts
        hosts = sorted(set(f["host"] for f in self.files_all_files))
        
        # Create scrollable frame for tabs
        tabs_scroll = ctk.CTkScrollableFrame(
            self.files_tabs_frame,
            orientation="horizontal",
            height=50
        )
        tabs_scroll.pack(fill="x", expand=True)
        
        # Apply current filters for counting
        def get_filtered_count(files_list):
            """Apply current filters to get accurate count"""
            filtered = files_list.copy()
            
            # Filter by type
            file_type = self.files_type_var.get()
            type_map = {
                "–ó–∞–ø–∏—Å–∏": "recording",
                "–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏": "transcript",
                "–û—Ç—á–µ—Ç—ã": "report"
            }
            if file_type in type_map:
                filtered = [f for f in filtered if f["type"] == type_map[file_type]]
            
            # Filter by period
            period = self.files_period_var.get()
            if period != "–í—Å–µ":
                now = datetime.now()
                if period == "–°–µ–≥–æ–¥–Ω—è":
                    cutoff = now.replace(hour=0, minute=0, second=0, microsecond=0)
                elif period == "–ù–µ–¥–µ–ª—è":
                    cutoff = now - timedelta(days=7)
                elif period == "–ú–µ—Å—è—Ü":
                    cutoff = now - timedelta(days=30)
                
                filtered = [f for f in filtered if f["date"] >= cutoff]
            
            # Filter by search
            search_query = self.files_search_var.get().lower()
            if search_query:
                filtered = [f for f in filtered if search_query in f["name"].lower()]
            
            return len(filtered)
        
        # "All files" tab
        all_count = get_filtered_count(self.files_all_files)
        btn_all = ctk.CTkButton(
            tabs_scroll,
            text=f"–í—Å–µ —Ñ–∞–π–ª—ã ({all_count})",
            command=lambda: self._files_select_host("–í—Å–µ —Ñ–∞–π–ª—ã"),
            fg_color="#3498db" if self.files_current_host == "–í—Å–µ —Ñ–∞–π–ª—ã" else "transparent",
            width=150
        )
        btn_all.pack(side="left", padx=2)
        
        # Host tabs
        for host in hosts:
            host_files = [f for f in self.files_all_files if f["host"] == host]
            count = get_filtered_count(host_files)
            
            btn = ctk.CTkButton(
                tabs_scroll,
                text=f"{host} ({count})",
                command=lambda h=host: self._files_select_host(h),
                fg_color="#3498db" if self.files_current_host == host else "transparent",
                width=150
            )
            btn.pack(side="left", padx=2)
    
    def _files_select_host(self, host_name):
        """Select a host tab"""
        self.files_current_host = host_name
        self._files_build_host_tabs()  # Rebuild to update highlighting
        self._files_refresh_list()
    
    def _files_activate_search(self, mode):
        """Activate search mode (global or user)"""
        self.files_search_mode = mode
        
        # Show search entry
        if mode == "global":
            self.files_search_entry.grid(row=0, column=2, padx=5, sticky="w")
            self.files_search_entry.focus()
        elif mode == "user":
            if self.files_current_host == "–í—Å–µ —Ñ–∞–π–ª—ã":
                messagebox.showinfo(
                    "–ü–æ–∏—Å–∫",
                    "–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—Ö–æ—Å—Ç–∞) –∏–∑ —Ç–∞–±–æ–≤"
                )
                return
            self.files_search_entry.grid(row=0, column=2, padx=5, sticky="w")
            self.files_search_entry.focus()
    
    def _files_clear_filters(self):
        """Clear all filters and search"""
        self.files_type_var.set("–í—Å–µ")
        self.files_sort_var.set("–î–∞—Ç–∞ ‚Üì")
        self.files_period_var.set("–í—Å–µ")
        self.files_search_var.set("")
        self.files_search_mode = None
        self.files_search_entry.grid_forget()
        self.files_current_host = "–í—Å–µ —Ñ–∞–π–ª—ã"
        self._files_build_host_tabs()
        self._files_refresh_list()
    
    def _files_refresh_list(self):
        """Refresh the files list with current filters"""
        # Rebuild tabs to update counters with current filters
        self._files_build_host_tabs()
        
        # Clear table
        for widget in self.files_table_frame.winfo_children():
            widget.destroy()
        
        # Apply filters
        filtered_files = self.files_all_files.copy()
        
        # Filter by host
        if self.files_current_host != "–í—Å–µ —Ñ–∞–π–ª—ã":
            filtered_files = [f for f in filtered_files if f["host"] == self.files_current_host]
        
        # Filter by type
        file_type = self.files_type_var.get()
        type_map = {
            "–ó–∞–ø–∏—Å–∏": "recording",
            "–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏": "transcript",
            "–û—Ç—á–µ—Ç—ã": "report"
        }
        if file_type in type_map:
            filtered_files = [f for f in filtered_files if f["type"] == type_map[file_type]]
        
        # Filter by period
        period = self.files_period_var.get()
        if period != "–í—Å–µ":
            now = datetime.now()
            if period == "–°–µ–≥–æ–¥–Ω—è":
                cutoff = now.replace(hour=0, minute=0, second=0, microsecond=0)
            elif period == "–ù–µ–¥–µ–ª—è":
                cutoff = now - timedelta(days=7)
            elif period == "–ú–µ—Å—è—Ü":
                cutoff = now - timedelta(days=30)
            
            filtered_files = [f for f in filtered_files if f["date"] >= cutoff]
        
        # Filter by search
        search_query = self.files_search_var.get().lower()
        if search_query:
            filtered_files = [f for f in filtered_files if search_query in f["name"].lower()]
        
        # Sort
        sort_mode = self.files_sort_var.get()
        if sort_mode == "–î–∞—Ç–∞ ‚Üì":
            filtered_files.sort(key=lambda f: f["date"], reverse=True)
        elif sort_mode == "–î–∞—Ç–∞ ‚Üë":
            filtered_files.sort(key=lambda f: f["date"])
        elif sort_mode == "–ò–º—è A-Z":
            filtered_files.sort(key=lambda f: f["name"].lower())
        elif sort_mode == "–ò–º—è Z-A":
            filtered_files.sort(key=lambda f: f["name"].lower(), reverse=True)
        
        # Display files
        if not filtered_files:
            ctk.CTkLabel(
                self.files_table_frame,
                text="–§–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã",
                font=("Segoe UI", 14),
                text_color="gray"
            ).pack(pady=50)
            return
        
        # Table header
        header = ctk.CTkFrame(self.files_table_frame)
        header.pack(fill="x", padx=5, pady=(5, 10))
        header.grid_columnconfigure(1, weight=1)  # Name column expands
        
        ctk.CTkLabel(header, text="–¢–∏–ø", width=60, font=("Segoe UI", 11, "bold")).grid(row=0, column=0, padx=5)
        ctk.CTkLabel(header, text="–ò–º—è —Ñ–∞–π–ª–∞", width=300, font=("Segoe UI", 11, "bold"), anchor="w").grid(row=0, column=1, padx=5, sticky="w")
        ctk.CTkLabel(header, text="–•–æ—Å—Ç", width=150, font=("Segoe UI", 11, "bold")).grid(row=0, column=2, padx=5)
        ctk.CTkLabel(header, text="–î–∞—Ç–∞", width=120, font=("Segoe UI", 11, "bold")).grid(row=0, column=3, padx=5)
        ctk.CTkLabel(header, text="–†–∞–∑–º–µ—Ä", width=80, font=("Segoe UI", 11, "bold")).grid(row=0, column=4, padx=5)
        ctk.CTkLabel(header, text="–î–µ–π—Å—Ç–≤–∏—è", width=220, font=("Segoe UI", 11, "bold")).grid(row=0, column=5, padx=5)
        
        # File rows
        for file_data in filtered_files:
            row = ctk.CTkFrame(self.files_table_frame)
            row.pack(fill="x", padx=5, pady=2)
            row.grid_columnconfigure(1, weight=1)
            
            # Icon
            icon_map = {
                "recording": "üéôÔ∏è",
                "transcript": "üìÑ",
                "report": "üìä"
            }
            icon = icon_map.get(file_data["type"], "üìÅ")
            ctk.CTkLabel(row, text=icon, width=60).grid(row=0, column=0, padx=5)
            
            # Name
            name_label = ctk.CTkLabel(row, text=file_data["name"], width=300, anchor="w")
            name_label.grid(row=0, column=1, padx=5, sticky="w")
            
            # Host
            ctk.CTkLabel(row, text=file_data["host"], width=150).grid(row=0, column=2, padx=5)
            
            # Date
            date_str = file_data["date"].strftime("%d.%m.%Y %H:%M")
            ctk.CTkLabel(row, text=date_str, width=120).grid(row=0, column=3, padx=5)
            
            # Size
            size_mb = file_data["size"] / (1024 * 1024)
            size_str = f"{size_mb:.1f} MB" if size_mb >= 1 else f"{file_data['size'] // 1024} KB"
            ctk.CTkLabel(row, text=size_str, width=80).grid(row=0, column=4, padx=5)
            
            # Actions
            actions = ctk.CTkFrame(row)
            actions.grid(row=0, column=5, padx=5)
            
            ctk.CTkButton(
                actions, text="–û—Ç–∫—Ä—ã—Ç—å", width=60,
                command=lambda p=file_data["path"]: self._files_open_file(p)
            ).pack(side="left", padx=2)
            
            ctk.CTkButton(
                actions, text="–ü–∞–ø–∫–∞", width=60,
                command=lambda p=file_data["path"]: self._files_show_in_folder(p)
            ).pack(side="left", padx=2)
            
            ctk.CTkButton(
                actions, text="–£–¥–∞–ª–∏—Ç—å", width=70,
                fg_color="#e74c3c", hover_color="#c0392b",
                command=lambda p=file_data["path"]: self._files_delete_file(p)
            ).pack(side="left", padx=2)
    
    def _files_open_file(self, filepath):
        """Open file in default application"""
        try:
            os.startfile(filepath)
            self._log(f"–û—Ç–∫—Ä—ã—Ç —Ñ–∞–π–ª: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª:\n{e}")
    
    def _files_show_in_folder(self, filepath):
        """Show file in Windows Explorer"""
        try:
            subprocess.run(["explorer", "/select,", filepath])
            self._log(f"–ü–æ–∫–∞–∑–∞–Ω –≤ –ø—Ä–æ–≤–æ–¥–Ω–∏–∫–µ: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–≤–æ–¥–Ω–∏–∫:\n{e}")
    
    def _files_delete_file(self, filepath):
        """Delete file with confirmation"""
        filename = os.path.basename(filepath)
        confirm = messagebox.askyesno(
            "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ",
            f"–£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª?\n\n{filename}"
        )
        
        if confirm:
            try:
                os.remove(filepath)
                self._log(f"–£–¥–∞–ª—ë–Ω —Ñ–∞–π–ª: {filename}")
                # Refresh
                self._files_scan_all()
                self._files_build_host_tabs()
                self._files_refresh_list()
                messagebox.showinfo("–£—Å–ø–µ—Ö", f"–§–∞–π–ª —É–¥–∞–ª—ë–Ω:\n{filename}")
            except Exception as e:
                messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª:\n{e}")

    def _update_speakers_box(self):
        self.speakers_box.configure(state="normal")
        self.speakers_box.delete("0.0", "end")
        for name in self.voice_db.keys():
            self.speakers_box.insert("end", f"{name}\n")
        self.speakers_box.configure(state="disabled")

    def _on_speakers_changed(self):
        self._save_db()
        self._update_speakers_box()
        self._refresh_host_menu()

    def _refresh_host_menu(self):
        names = sorted(list(self.voice_db.keys())) or ["–î–æ–±–∞–≤—å—Ç–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞"]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∞—Ç—Ä–∏–±—É—Ç –∏ —Å–∞–º –≤–∏–¥–∂–µ—Ç
        if hasattr(self, "host_menu") and self.host_menu is not None:
            try:
                # winfo_exists() –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –∂–∏–≤ –ª–∏ –≤–∏–¥–∂–µ—Ç –≤ Tkinter
                if self.host_menu.winfo_exists():
                    self.host_menu.configure(values=names)
                    
                    # –ï—Å–ª–∏ —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –≤–∞–ª–∏–¥–Ω–æ –∏–ª–∏ –ø—É—Å—Ç–æ, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞ –ø–µ—Ä–≤–æ–µ
                    current = self.host_menu.get()
                    if current not in names:
                        self.host_menu.set(names[0])
            except Exception:
                # –ï—Å–ª–∏ –≤–∏–¥–∂–µ—Ç —É–º–µ—Ä (–º—ã –Ω–∞ –¥—Ä—É–≥–æ–π –≤–∫–ª–∞–¥–∫–µ), –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                pass

    # --- —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å—å—é ---

    def _toggle_recording(self):
        if not self.is_recording:
            # --- –ù–ê–ß–ê–õ–û –ó–ê–ü–ò–°–ò ---
            host = self.host_menu.get()
            if not host or "–î–æ–±–∞–≤—å—Ç–µ" in host:
                self._log("–ù—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –≤–µ–¥—É—â–µ–≥–æ –≤—Å—Ç—Ä–µ—á–∏.")
                return

            topic = self.topic_entry.get().strip() or "–í—Å—Ç—Ä–µ—á–∞"
            safe_topic = sanitize_filename(topic)
            date_prefix = datetime.now().strftime("%Y-%m-%d")
            
            rec_dir, _, _ = self._get_host_dirs(host)
            filename = f"{date_prefix}_{safe_topic}_{sanitize_filename(host)}.{config.get('rec_format')}"
            full_path = os.path.join(rec_dir, filename)

            self.recorder.start(full_path)
            self.is_recording = True
            self.record_start_time = time.time()
            
            # UI –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            self.record_button.configure(text="‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", fg_color="red", hover_color="#8b0000")
            self.pause_button.configure(state="normal", text="‚è∏ –ü–∞—É–∑–∞", fg_color="#f39c12")
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä
            self.vu_meter_frame.grid()
            
            self._update_timer()
            self._update_vu_meter() # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–æ—Å–∫–∏
        else:
            # --- –û–°–¢–ê–ù–û–í–ö–ê –ó–ê–ü–ò–°–ò ---
            self.recorder.stop()
            full_path = self.recorder.final_target
            self._load_player(full_path)
            
            # –°—Ä–∞–∑—É –∞–Ω–∞–ª–∏–∑
            self._start_analysis(full_path)
            self.is_recording = False
            
            # UI –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            self.record_button.configure(text="‚è∫ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å", fg_color="green", hover_color="#006400")
            self.pause_button.configure(state="disabled", text="‚è∏ –ü–∞—É–∑–∞")
            self.timer_label.configure(text="00:00")
            
            # –°–∫—Ä—ã–≤–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä
            self.vu_meter_frame.grid_remove()
            
            # –°—Ä–∞–∑—É –∞–Ω–∞–ª–∏–∑
            full_path = self.recorder.final_target
            self._start_analysis(full_path)

    def _toggle_pause(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ –ü–∞—É–∑–∞"""
        if not self.is_recording:
            return
            
        is_paused = self.recorder.toggle_pause()
        if is_paused:
            self.pause_button.configure(text="‚ñ∂ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å", fg_color="#2ecc71", hover_color="#27ae60")
            self._log("–ó–∞–ø–∏—Å—å –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º—è —Å—Ç–∞—Ä—Ç–∞, —á—Ç–æ–±—ã —Ç–∞–π–º–µ—Ä –Ω–µ —Å–∫–∞–∫–Ω—É–ª –ø—Ä–∏ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏
            # (—É–ø—Ä–æ—â–µ–Ω–Ω–æ: –ø—Ä–æ—Å—Ç–æ –∑–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –≤ UI)
        else:
            self.pause_button.configure(text="‚è∏ –ü–∞—É–∑–∞", fg_color="#f39c12", hover_color="#d35400")
            self._log("–ó–∞–ø–∏—Å—å –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∞")
            # –ü—Ä–∏ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞–º –Ω—É–∂–Ω–æ —Å–¥–≤–∏–Ω—É—Ç—å record_start_time, 
            # –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º –∫–∞–∫ –µ—Å—Ç—å.
            
    def _update_vu_meter(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–æ—Å–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏"""
        if self.is_recording and hasattr(self, 'vu_meter'):
            vol = self.recorder.current_volume
            self.vu_meter.set(vol)
            # –ï—Å–ª–∏ –∑–∞–ø–∏—Å—å –∏–¥–µ—Ç, –ø–ª–∞–Ω–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 50–º—Å
            self.after(50, self._update_vu_meter)

    def _update_timer(self):
        if self.is_recording:
            # –ï—Å–ª–∏ –ø–∞—É–∑–∞, —Ç–∞–π–º–µ—Ä –≤–∏–∑—É–∞–ª—å–Ω–æ —Å—Ç–æ–∏—Ç (—Ö–æ—Ç—è –≤—Ä–µ–º—è "–≥—Ä—è–∑–Ω–æ–µ" –º–æ–∂–µ—Ç –∏–¥—Ç–∏, 
            # –Ω–æ –º—ã –ø–∏—à–µ–º —Ç–æ–ª—å–∫–æ –ø–æ–ª–µ–∑–Ω—ã–π —Å–∏–≥–Ω–∞–ª, —Ç–∞–∫ —á—Ç–æ –ª–æ–≥–∏—á–Ω–æ –Ω–µ –∫—Ä—É—Ç–∏—Ç—å —Å—á–µ—Ç—á–∏–∫)
            if not self.recorder.paused:
                # –í –∏–¥–µ–∞–ª–µ –∑–¥–µ—Å—å –Ω—É–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å "—á–∏—Å—Ç–æ–µ" –≤—Ä–µ–º—è –∑–∞–ø–∏—Å–∏,
                # –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º –æ—Ç—Å–µ—á–∫—É –æ—Ç —Å—Ç–∞—Ä—Ç–∞.
                # –î–ª—è –≤–µ—Ä—Å–∏–∏ 1.0 –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å Accumulator –≤—Ä–µ–º–µ–Ω–∏.
                elapsed = int(time.time() - self.record_start_time)
                self.timer_label.configure(text=f"{elapsed // 60:02}:{elapsed % 60:02}")
            
            self.after(1000, self._update_timer)

    # --- –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞ ---

    def _pick_file(self):
        path = filedialog.askopenfilename()
        if not path:
            return
        self.selected_file_label.configure(text=os.path.basename(path))
        
        # Store audio path for associations
        self.current_audio_path = path
        
        # Check for associated transcript
        transcript_path = self.file_assoc.get_transcript(path)
        if transcript_path and os.path.exists(transcript_path):
            self._log(f"üîó –ù–∞–π–¥–µ–Ω —Å–≤—è–∑–∞–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç: {os.path.basename(transcript_path)}")
            # Load transcript into UI
            try:
                with open(transcript_path, 'r', encoding='utf-8') as f:
                    text = f.read()
                self.last_transcript_text = text
                self.current_transcript_path = transcript_path
                
                # Parse and display if possible
                self._parse_and_render_transcript(text)
                
                # Enable save button
                if hasattr(self, 'save_transcript_btn'):
                    self.save_transcript_btn.configure(state="normal")
            except Exception as e:
                self._log(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {e}")
        
        # Load audio to player
        self._load_player(path)
        
        # Run analysis
        self._start_analysis(path)

    def _load_player(self, path):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –≤ –ø–ª–µ–µ—Ä –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ UI"""
        self._log(f"–ó–∞–≥—Ä—É–∑–∫–∞ –∞—É–¥–∏–æ –≤ –ø–ª–µ–µ—Ä: {os.path.basename(path)}...")
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –≤ –ø–æ—Ç–æ–∫–µ, —á—Ç–æ–±—ã –Ω–µ –º–æ—Ä–æ–∑–∏—Ç—å GUI –Ω–∞ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–∞—Ö
        threading.Thread(target=self._load_player_thread, args=(path,), daemon=True).start()

    def _load_player_thread(self, path):
        success = self.player.load(path)
        if success:
            self.after(0, self._player_ui_ready)
        else:
            self._log("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—É–¥–∏–æ –¥–ª—è –ø–ª–µ–µ—Ä–∞.")

    def _player_ui_ready(self):
        """–ê–∫—Ç–∏–≤–∞—Ü–∏—è UI –ø–ª–µ–µ—Ä–∞ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏"""
        if not hasattr(self, "player_frame"): return
        
        self.player_frame.grid() # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–ª–µ–µ—Ä
        self.player_slider.configure(from_=0, to=self.player.duration_sec)
        self.player_slider.set(0)
        self.player_btn.configure(text="‚ñ∂")
        self._update_player_time_lbl(0, self.player.duration_sec)
        self._log("–ê—É–¥–∏–æ –≥–æ—Ç–æ–≤–æ –∫ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é.")
        # –ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI
        self._player_update_loop()

    def _player_toggle(self):
        """Play/Pause"""
        if self.player.is_playing:
            self.player.pause()
            self.player_btn.configure(text="‚ñ∂")
        else:
            self.player.play()
            self.player_btn.configure(text="‚è∏")

    def _player_on_slide(self, value):
        """–ü–µ—Ä–µ–º–æ—Ç–∫–∞ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ —Å–ª–∞–π–¥–µ—Ä–∞)"""
        self.player.seek(float(value))
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–º–∞—Ç—ã–≤–∞–µ–º, –æ–±–Ω–æ–≤–ª—è–µ–º –ª–µ–π–±–ª —Å—Ä–∞–∑—É
        curr, total = self.player.get_pos()
        self._update_player_time_lbl(curr, total)

    def _update_player_time_lbl(self, curr, total):
        def fmt(s):
            m = int(s // 60)
            sec = int(s % 60)
            return f"{m:02}:{sec:02}"
        self.player_time_lbl.configure(text=f"{fmt(curr)} / {fmt(total)}")

    def _player_update_loop(self):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–∞–π–¥–µ—Ä–∞ –∏ –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏–∏"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–ª–µ–µ—Ä –Ω–∞ —ç–∫—Ä–∞–Ω–µ
        if not hasattr(self, "player_frame") or not self.player_frame.winfo_exists():
            return
            
        if self.player.is_playing:
            curr, total = self.player.get_pos()
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–∞–π–¥–µ—Ä, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ–≥–æ –Ω–µ —Ç–∞—â–∏—Ç (—Å–ª–æ–∂–Ω–æ –æ—Ç—Å–ª–µ–¥–∏—Ç—å –≤ ctk, 
            # –ø–æ—ç—Ç–æ–º—É –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º, ctk –æ–±—ã—á–Ω–æ —Å–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è)
            self.player_slider.set(curr)
            self._update_player_time_lbl(curr, total)
            
            # –ï—Å–ª–∏ –¥–æ–∏–≥—Ä–∞–ª–æ –¥–æ –∫–æ–Ω—Ü–∞
            if curr >= total and total > 0:
                self.player_btn.configure(text="‚ñ∂")
        
        # –ü–æ–≤—Ç–æ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 250 –º—Å
        self.after(250, self._player_update_loop)

    def _pick_transcript_file(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –≥–æ—Ç–æ–≤–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞"""
        path = filedialog.askopenfilename(filetypes=[("Text Files", "*.txt")])
        if not path:
            return
            
        try:
            with open(path, "r", encoding="utf-8") as f:
                text = f.read()
            
            # Save transcript data
            self.last_transcript_text = text
            self.last_basename = os.path.splitext(os.path.basename(path))[0]
            self.current_transcript_path = path
            
            # Update UI
            self.selected_file_label.configure(text=f"–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç: {os.path.basename(path)}")
            
            # Parse and render using helper method
            self._parse_and_render_transcript(text)
            
            # Check for associated audio file
            audio_path = self.file_assoc.get_audio(path)
            if audio_path and os.path.exists(audio_path):
                self._log(f"üîó –ù–∞–π–¥–µ–Ω —Å–≤—è–∑–∞–Ω–Ω—ã–π –∞—É–¥–∏–æ —Ñ–∞–π–ª: {os.path.basename(audio_path)}")
                self.current_audio_path = audio_path
                self._load_player(audio_path)
            
            # Enable buttons
            if hasattr(self, "report_button_file") and self.report_button_file.winfo_exists():
                self.report_button_file.configure(state="normal")
            
            if hasattr(self, "save_transcript_btn") and self.save_transcript_btn.winfo_exists():
                self.save_transcript_btn.configure(state="normal")
            
            self._log(f"–ó–∞–≥—Ä—É–∂–µ–Ω —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç: {os.path.basename(path)}")
            
        except Exception as e:
            self._log(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª:\n{e}")

    def _start_analysis(self, path: str):
        self._log("–ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –∞—É–¥–∏–æ...")
        threading.Thread(target=self._run_analysis, args=(path,), daemon=True).start()

    def _run_analysis(self, path: str):
        try:
            self.after(0, lambda: self._show_progress_ui(True)) # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º UI
            
            try:
                logger.info(f"Starting analysis of: {path}")
                # –ü–ï–†–ï–î–ê–ï–ú self.stop_event
                segments, unknown = self.ai.analyze(path, self.voice_db, self._log, self.stop_event)
                logger.info(f"Analysis completed. Segments: {len(segments)}, Unknown: {len(unknown)}")
            except OperationCancelled:
                self._log("‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ –æ—Ç–º–µ–Ω–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
                return # –í—ã—Ö–æ–¥–∏–º, –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—è –Ω–∏—á–µ–≥–æ
            except Exception as e:
                self._log(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {e}")
                logger.error(f"Analysis failed: {e}", exc_info=True)
                return

            if unknown:
                self._log("–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –≥–æ–ª–æ—Å–∞, –∑–∞–ø—É—Å–∫–∞—é –º–∞—Å—Ç–µ—Ä...")
                # –ü—Ä–∏ –º–∞—Å—Ç–µ—Ä–µ –æ—Ç–º–µ–Ω—É –ø–æ–∫–∞ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º, —Ç–∞–º UI
                wizard = IdentifyWizard(self, unknown, self.voice_db)
                self.wait_window(wizard)
                
                # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–µ –≥–æ–ª–æ—Å–∞
                for spk_id, name in wizard.result_names.items():
                    if wizard.save_flags.get(spk_id):
                        sample = unknown[spk_id]
                        try:
                            emb = self.ai.create_embedding(sample["audio"])
                            
                            if name in self.voice_db and isinstance(self.voice_db[name], dict):
                                self.voice_db[name]["embedding"] = emb
                                self.voice_db[name]["trained"] = True
                            else:
                                self.voice_db[name] = {
                                    "embedding": emb,
                                    "trained": True,
                                    "sample_count": 1
                                }
                        except Exception as e:
                            logger.error(f"Error creating embedding for {name}: {e}")

                self._save_db()
                self._refresh_host_menu()
                
                # –ø–µ—Ä–µ–∏–º–µ–Ω—É–µ–º –º–µ—Ç–∫–∏ –≤ —Å–µ–≥–º–µ–Ω—Ç–∞—Ö
                for seg in segments:
                    label = seg["label"]
                    if label in wizard.result_names:
                        seg["label"] = wizard.result_names[label]

            # —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—É
            transcript = "\n".join(
                f"[{s['start']:.1f}] {s['label']}: {s['text']}"
                for s in segments
                if s["text"].strip()
            )
            self.last_transcript_text = transcript
            self.last_basename = os.path.splitext(os.path.basename(path))[0]
            
            # Render segments in UI
            self.after(0, lambda: self._render_transcript(segments))

            if config.get("save_txt"):
                host_name = "Unknown_Host"
                try:
                    parts = self.last_basename.split("_")
                    if len(parts) >= 3:
                        host_name = parts[-1]
                    elif hasattr(self, "host_menu"):
                        val = self.host_menu.get()
                        if val and "–î–æ–±–∞–≤—å—Ç–µ" not in val:
                            host_name = val
                except Exception:
                    pass

                _, trans_dir, _ = self._get_host_dirs(host_name)
                
                txt_path = os.path.join(
                    trans_dir, f"{self.last_basename}.txt"
                )
                with open(txt_path, "w", encoding="utf-8") as f:
                    f.write(transcript)
                self._log(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º–∞: {txt_path}")
                
                # Store transcript path and create association
                self.current_transcript_path = txt_path
                if hasattr(self, 'current_audio_path') and self.current_audio_path:
                    self.file_assoc.associate(self.current_audio_path, txt_path)
                    self._log("üîó –°–æ–∑–¥–∞–Ω–∞ —Å–≤—è–∑—å –∞—É–¥–∏–æ ‚Üî —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç")
                
                if config.get("save_srt"):
                     srt_path = os.path.join(trans_dir, f"{self.last_basename}.srt")
                     SRTGenerator.create_srt(segments, srt_path)
                     self._log(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω—ã —Å—É–±—Ç–∏—Ç—Ä—ã: {srt_path}")

            # –í–∫–ª—é—á–∞–µ–º –∫–Ω–æ–ø–∫–∏ —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π —Ö–µ–ª–ø–µ—Ä
            self.after(0, lambda: self._enable_report_buttons())

        finally:
            self.after(0, lambda: self._show_progress_ui(False)) # –°–∫—Ä—ã–≤–∞–µ–º UI
            if os.path.exists(TEMP_DIR):
                try: shutil.rmtree(TEMP_DIR)
                except: pass

   
    
    def _stop_progress(self):
        self.after(
            0,
            lambda: (
                self.progress.stop(),
                self.progress.pack_forget(),
            ),
        )

    # --- –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á—ë—Ç–∞ LLM ---

    def _generate_report(self):
        if not self.last_transcript_text:
            self._log("–ù–µ—Ç —Å—Ç–µ–Ω–æ–≥—Ä–∞–º–º—ã –¥–ª—è –æ—Ç—á—ë—Ç–∞.")
            return

        # Show status (assuming status_label exists or using log)
        self._log("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á—ë—Ç–∞...")
        
        threading.Thread(target=self._llm_report_thread, daemon=True).start()

    def _llm_report_thread(self):
        self.after(0, lambda: self._show_progress_ui(True))
        self._token_counter = 0
        
        def on_progress(data):
            is_status_msg = (len(data) > 80 or data.startswith("–ê–Ω–∞–ª–∏–∑") or data.startswith("–°–±–æ—Ä–∫–∞") or data.startswith("–†–µ–∂–∏–º"))
            if is_status_msg:
                self.after(0, lambda: self.status_label.configure(text=data))
            else:
                self._token_counter += 1
                if self._token_counter % 2 == 0:
                    msg = f"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è... ({self._token_counter} —Ç–æ–∫.)"
                    self.after(0, lambda: self.status_label.configure(text=msg))

        try:
            # Collect transcript from UI (with user edits!)
            transcript_text = self._collect_transcript_from_ui()
            
            # Fallback to last_transcript_text if UI is empty
            if not transcript_text and self.last_transcript_text:
                transcript_text = self.last_transcript_text
            
            if not transcript_text:
                self._log("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á—ë—Ç–∞")
                return
            
            # –ü–ï–†–ï–î–ê–ï–ú stop_event
            report = self.llm.summarize(transcript_text, progress_cb=on_progress, stop_event=self.stop_event)
            
            if config.get("save_docx"):
                host_name = "Unknown_Host"
                try:
                    parts = self.last_basename.split("_")
                    if len(parts) >= 3: host_name = parts[-1]
                    elif hasattr(self, "host_menu"): 
                         val = self.host_menu.get()
                         if val and "–î–æ–±–∞–≤—å—Ç–µ" not in val: host_name = val
                except: pass
                _, _, rep_dir = self._get_host_dirs(host_name)
                docx_path = os.path.join(rep_dir, f"{self.last_basename}_report.docx")
                DocxGenerator.create_report(report, docx_path)
                self._log(f"–°–æ—Ö—Ä–∞–Ω—ë–Ω –æ—Ç—á—ë—Ç: {docx_path}")
                final_msg = f"–û—Ç—á—ë—Ç –≥–æ—Ç–æ–≤! ({self._token_counter} —Ç–æ–∫.)"
                self.after(0, lambda: self.status_label.configure(text=final_msg))

                if config.get("use_gdrive"):
                    self.gdrive.upload(docx_path)

        except OperationCancelled:
            self._log("‚ö†Ô∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –ø—Ä–µ—Ä–≤–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
        except Exception as e:
            self._log(f"–û—à–∏–±–∫–∞ LLM: {e}")
        finally:
            self.after(0, lambda: self._show_progress_ui(False))

    # --- —Ä–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π —Å–ø–∏–∫–µ—Ä–æ–≤ ---

    def _remove_speaker(self):
        if not self.voice_db:
            return
        win = ctk.CTkToplevel(self)
        win.title("–£–¥–∞–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞")
        win.geometry("300x120")
        ctk.CTkLabel(win, text="–ö–æ–≥–æ —É–¥–∞–ª–∏—Ç—å?").pack(pady=10)
        var = ctk.StringVar(value=list(self.voice_db.keys())[0])
        ctk.CTkOptionMenu(win, variable=var,
                          values=list(self.voice_db.keys())
                          ).pack(pady=5)

        def do_delete():
            self.voice_db.pop(var.get(), None)
            self._save_db()
            self._update_speakers_box()
            self._refresh_host_menu()
            win.destroy()

        ctk.CTkButton(
            win, text="–£–¥–∞–ª–∏—Ç—å", fg_color="red", command=do_delete
        ).pack(pady=10)

    # === SPEAKER TRAINING METHODS ===
    
    def _quick_train_speaker(self, name):
        """Train or re-train a speaker using all their samples"""
        import glob
        
        speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
        samples = sorted(glob.glob(os.path.join(speaker_dir, "sample_*.wav")))
        
        if not samples:
            self._log(f"–ù–µ—Ç —Å–µ–º–ø–ª–æ–≤ –¥–ª—è {name}")
            return
        
        self._log(f"–û–±—É—á–µ–Ω–∏–µ {name} –Ω–∞ –æ—Å–Ω–æ–≤–µ {len(samples)} —Å–µ–º–ø–ª(–æ–≤)...")
        
        # Create embeddings from all samples and average them
        embeddings = []
        for sample_path in samples:
            try:
                emb = self.ai.create_embedding(sample_path)
                embeddings.append(emb)
            except Exception as e:
                logger.warning(f"Failed to process {sample_path}: {e}")
        
        if not embeddings:
            self._log(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–µ–º–ø–ª—ã –¥–ª—è {name}")
            return
        
        # Average embeddings for better accuracy
        avg_embedding = np.mean(embeddings, axis=0)
        
        # Update voice_db
        if isinstance(self.voice_db.get(name), dict):
            self.voice_db[name]["embedding"] = avg_embedding
            self.voice_db[name]["trained"] = True
            self.voice_db[name]["sample_count"] = len(samples)
        else:
            self.voice_db[name] = {
                "embedding": avg_embedding,
                "trained": True,
                "sample_count": len(samples)
            }
        
        self._save_db()
        # Update UI if on voices page
        if hasattr(self, 'current_page') and self.current_page == "voices":
            self._show_voices_page()
        self._log(f"‚úÖ {name} –æ–±—É—á–µ–Ω (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ {len(embeddings)} —Å–µ–º–ø–ª(–æ–≤))")
    
    def _train_all_speakers(self):
        """Batch train all untrained speakers with samples"""
        untrained = []
        for name, data in self.voice_db.items():
            if isinstance(data, dict):
                is_trained = data.get("trained", True)
                has_samples = data.get("sample_count", 0) > 0
                if not is_trained and has_samples:
                    untrained.append(name)
        
        if not untrained:
            self._log("‚úÖ –í—Å–µ —Å–ø–∏–∫–µ—Ä—ã —É–∂–µ –æ–±—É—á–µ–Ω—ã!")
            return
        
        self._log(f"–ù–∞—á–∏–Ω–∞—é –æ–±—É—á–µ–Ω–∏–µ {len(untrained)} —Å–ø–∏–∫–µ—Ä–æ–≤...")
        
        for i, name in enumerate(untrained, 1):
            self._log(f"[{i}/{len(untrained)}] {name}...")
            self._quick_train_speaker(name)
        
        self._log(f"üéâ –ü–∞–∫–µ—Ç–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –û–±—É—á–µ–Ω–æ: {len(untrained)}")
    
    def _remove_speaker_by_name(self, name):
        """Remove a speaker by name with confirmation"""
        import shutil
        
        result = messagebox.askyesno(
            "–£–¥–∞–ª–∏—Ç—å —Å–ø–∏–∫–µ—Ä–∞",
            f"–£–¥–∞–ª–∏—Ç—å {name} –∏–∑ –±–∞–∑—ã?\n–í—Å–µ —Å–µ–º–ø–ª—ã —Ç–∞–∫–∂–µ –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã."
        )
        if result:
            # Remove from database
            if name in self.voice_db:
                self.voice_db.pop(name)
                self._save_db()
            
            # Remove samples folder
            speaker_dir = os.path.join(SAMPLES_DIR, sanitize_filename(name))
            if os.path.exists(speaker_dir):
                shutil.rmtree(speaker_dir)
            
            self._log(f"–£–¥–∞–ª—ë–Ω: {name}")
            # Refresh page
            self._show_voices_page()
    
    def _retrain_after_sample(self, name):
        """Called after adding a new sample - retrain the speaker"""
        threading.Thread(
            target=self._quick_train_speaker,
            args=(name,),
            daemon=True
        ).start()
        # Refresh voices page
        self._show_voices_page()


if __name__ == "__main__":
    app = App()
    app.mainloop()
